{"meta":{"title":"哈欠星人","subtitle":"","description":"","author":"哈欠星人","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-04-16T01:13:47.000Z","updated":"2023-04-26T12:21:14.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"足迹本科(2015-2019) —— 上海交通大学硕士(2019-2022) —— 上海交通大学算法工程师(2022- ) —— hidden content 联系方式Email: &#51;&#50;&#x39;&#48;&#55;&#x30;&#49;&#53;&#50;&#50;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;"},{"title":"categories","date":"2022-04-15T18:16:09.000Z","updated":"2022-04-16T01:01:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-15T18:16:20.000Z","updated":"2022-04-16T01:01:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-04-15T18:16:34.000Z","updated":"2022-04-15T18:19:34.000Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"pulp不同求解器设置参数","slug":"pulp不同求解器设置参数","date":"2023-04-26T12:23:27.000Z","updated":"2023-04-26T13:53:40.000Z","comments":true,"path":"2023/04/26/pulp不同求解器设置参数/","link":"","permalink":"http://example.com/2023/04/26/pulp%E4%B8%8D%E5%90%8C%E6%B1%82%E8%A7%A3%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0/","excerpt":"Pulp provides an easy-to-use syntax and interface for formulating and solving LP problems, including support for a wide range of problem types and solvers. It is widely used in operations research, supply chain management, logistics, and other industries for making optimization decisions.","text":"Pulp provides an easy-to-use syntax and interface for formulating and solving LP problems, including support for a wide range of problem types and solvers. It is widely used in operations research, supply chain management, logistics, and other industries for making optimization decisions. 1234567891011121314151617181920212223from pulp import *# Use CBC solverprob.solve(PULP_CBC_CMD(msg=True, timeLimit=1, options=[&quot;startalg&quot;, &quot;barrier&quot;]))# Use cplex solverprob.solve( CPLEX_CMD(msg=True, timeLimit=1, # interactive cmd options=[&quot;set emphasis mip 3&quot;, &quot;set barrier algorithm 3&quot;]))# Use gurobi solverprob.solve( GUROBI_CMD(msg=True, timeLimit=1, threads=4, options=[(&quot;Method&quot;, 2), (&quot;MIPGap&quot;, 0.2)]))# Use scip solver, latest version of pulp only# support single thread onlyprob.solve(SCIP_CMD(msg=True, timeLimit=1, options=[&quot;branching/clamp=0.4&quot;]))","categories":[{"name":"优化","slug":"优化","permalink":"http://example.com/categories/%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"pulp","slug":"pulp","permalink":"http://example.com/tags/pulp/"},{"name":"solver","slug":"solver","permalink":"http://example.com/tags/solver/"},{"name":"mip","slug":"mip","permalink":"http://example.com/tags/mip/"}]},{"title":"Accelerate Your NumPy Matrix Operations with Cython","slug":"Accelerate Your NumPy Matrix Operations with Cython","date":"2023-03-31T00:44:10.000Z","updated":"2023-04-26T14:03:36.000Z","comments":true,"path":"2023/03/31/Accelerate Your NumPy Matrix Operations with Cython/","link":"","permalink":"http://example.com/2023/03/31/Accelerate%20Your%20NumPy%20Matrix%20Operations%20with%20Cython/","excerpt":"python #cythonIntroductionPython is widely used for scientific computing, data analysis, and machine learning tasks due to its ease of use and rich ecosystem. NumPy, a popular library for numerical computations in Python, provides a powerful array object and a variety of functions to operate on these arrays. However, performance can sometimes be a bottleneck when working with large datasets or complex operations.","text":"python #cythonIntroductionPython is widely used for scientific computing, data analysis, and machine learning tasks due to its ease of use and rich ecosystem. NumPy, a popular library for numerical computations in Python, provides a powerful array object and a variety of functions to operate on these arrays. However, performance can sometimes be a bottleneck when working with large datasets or complex operations.Cython, a superset of the Python language, allows you to write Python code with optional C-like syntax and static types, which can then be compiled to C and executed as a native extension. This can lead to significant performance improvements compared to pure Python code. In this blog post, we will demonstrate how to use Cython with NumPy to optimize matrix operations, and compare the performance of pure Python and Cython-accelerated implementations. PrerequisitesTo follow along with the examples in this post, make sure you have both Cython and NumPy installed: pip install cython numpy Example: Element-wise Matrix MultiplicationLet’s start by implementing element-wise matrix multiplication using Cython with NumPy. Step 1: Create a Cython fileCreate a Cython file called matrix_mult_cython.pyx with the following code: 123456789101112131415# matrix_mult_cython.pyximport numpy as npcimport numpy as cnpcpdef cnp.ndarray[double, ndim=2] elementwise_multiply(cnp.ndarray[double, ndim=2] A, cnp.ndarray[double, ndim=2] B): cdef int nrows = A.shape[0] cdef int ncols = A.shape[1] cdef cnp.ndarray[double, ndim=2] result = np.zeros((nrows, ncols), dtype=np.float64) cdef int i, j for i in range(nrows): for j in range(ncols): result[i, j] = A[i, j] * B[i, j] return result Note: In Cython, the cimport statement is used to import C-level declarations from other Cython modules or libraries. It is similar to the regular Python import statement, but it specifically deals with importing C-level functions, types, and other constructs that are not part of the Python runtime. In the provided example, the line cimport numpy as cnp is used to import the Cython definitions for the NumPy library. This allows us to interact with NumPy arrays more efficiently, leading to performance improvements. The cnp alias is used in the same way as np for regular Python NumPy imports, but it refers to the C-level NumPy constructs. Step 2: Compile the Cython moduleCreate a setup.py file to build the Cython module: 123456789101112131415# setup.pyfrom setuptools import setup, Extensionfrom Cython.Build import cythonizeimport numpy as npext_modules = [ Extension(&quot;matrix_mult_cython&quot;, [&quot;matrix_mult_cython.pyx&quot;], include_dirs=[np.get_include()]) # Add the NumPy header files]setup( name=&#x27;Matrix Multiplication Cython Example&#x27;, ext_modules=cythonize(ext_modules), zip_safe=False,) Compile the Cython module by running the following command in your terminal: python setup.py build_ext --inplace Note: The zip_safe parameter is an option indicating whether the package can be safely installed and run from a zip archive without being extracted to the file system. When zip_safe is set to True, it means that the package can be installed and run directly from a zip archive without any issues. However, when set to False, it indicates that the package needs to be extracted to the file system before being executed. In the case of Cython-compiled extensions, it is generally recommended to set zip_safe=False. This is because Cython generates compiled C extensions (shared libraries or DLLs) that need to be accessed by the operating system’s dynamic loader, which often cannot read files from a zip archive. Step 3: Use the Cython module in your Python codeNow, you can use the compiled Cython module in your Python code: 12345678910111213# main.pyimport numpy as npfrom matrix_mult_cython import elementwise_multiplydef main(): A = np.random.rand(1000, 1000) B = np.random.rand(1000, 1000) result = elementwise_multiply(A, B) print(result)if __name__ == &quot;__main__&quot;: main() Run your Python code: python main.py Performance ComparisonTo compare the performance before and after using Cython, we can implement the same element-wise multiplication using pure Python with NumPy and then measure the execution time for both the pure Python and Cython-accelerated implementations. Pure Python ImplementationAdd a pure Python implementation of element-wise multiplication in main.py: 1234567891011def elementwise_multiply_python(A, B): assert A.shape == B.shape, &quot;Both matrices must have the same shape.&quot; nrows, ncols = A.shape result = np.zeros((nrows, ncols), dtype=np.float64) for i in range(nrows): for j in range(ncols): result[i, j] = A[i, j] * B[i, j] return result Timing the ImplementationsAdd timing code to main.py to measure the execution time of both the pure Python and Cython-accelerated implementations: 1234567891011121314151617181920212223import timedef main(): A = np.random.rand(1000, 1000) B = np.random.rand(1000, 1000) # Time the pure Python implementation start_python = time.time() result_python = elementwise_multiply_python(A, B) end_python = time.time() elapsed_python = end_python - start_python # Time the Cython-accelerated implementation start_cython = time.time() result_cython = elementwise_multiply(A, B) end_cython = time.time() elapsed_cython = end_cython - start_cython print(f&quot;Pure Python: &#123;elapsed_python:.5f&#125; seconds&quot;) print(f&quot;Cython-accelerated: &#123;elapsed_cython:.5f&#125; seconds&quot;)if __name__ == &quot;__main__&quot;: main() Run the Python code: python main.py You should see the execution time of both the pure Python implementation and the Cython-accelerated implementation. Typically, the Cython-accelerated implementation should be significantly faster, as it leverages C-level array access and efficient looping. This is the result on my machine: ConclusionIn this blog post, we demonstrated how to use Cython with NumPy to optimize matrix operations, specifically element-wise matrix multiplication. We also compared the performance of pure Python and Cython-accelerated implementations, showing that Cython can provide significant performance improvements. Cython is a powerful tool for optimizing Python code that relies on numerical computations, especially when used in conjunction with libraries like NumPy. By taking advantage of C-level array access and efficient looping, you can achieve substantial speedups in your scientific computing, data analysis, and machine learning tasks.","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"cython","slug":"cython","permalink":"http://example.com/tags/cython/"}]},{"title":"2. 基于Django Rest框架构建API","slug":"基于Django-Rest框架构建API","date":"2022-12-31T09:58:24.000Z","updated":"2023-04-26T14:05:28.000Z","comments":true,"path":"2022/12/31/基于Django-Rest框架构建API/","link":"","permalink":"http://example.com/2022/12/31/%E5%9F%BA%E4%BA%8EDjango-Rest%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BAAPI/","excerpt":"1. 什么是API?简单看一下百科的解释： API之主要目的是提供应用程序与开发人员以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。提供API所定义的功能的软件称作此API的实现。API是一种接口，故而是一种抽象。 应用程序接口（英语：ApplicationProgrammingInterface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。","text":"1. 什么是API?简单看一下百科的解释： API之主要目的是提供应用程序与开发人员以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。提供API所定义的功能的软件称作此API的实现。API是一种接口，故而是一种抽象。 应用程序接口（英语：ApplicationProgrammingInterface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。 简单来说，我们写程序是为了帮用户完成某件事，用户不需要知道我们是怎么完成的。对于用户来说，只需发个指令，譬如，“我想导航到萧山”，那么程序能把路线告诉用户即可。API是什么呢，就是接受用户指令，并返回程序结果的一个工具。 2. 安装djangorestframework包作为网络开发程序员，我们要为用户提供API 并告诉用户如何使用我们的软件。用于开发API的工具有很多，在Django项目中，一般使用djangorestframework包来开发API。 djangorestframework包直接使用pip安装即可 1pip install djangorestframework 3. 建立Django项目在本文中，我们通过建立一个电影网站，让用户 获取、修改以及增加新的电影信息，以熟悉Django API的构建。 可以参考[[基本Django项目构建]]一文建立起项目，简单列举一下相关命令。 12345django-admin startproject movie_apicd movie_apipython manage.py startapp movie # 这里记得在配置文件中加入moviepython manage.py migratepython manage.py runserver 这样就可以跑起来一个空项目了。 因为本文只关注API的构建，这里只建立一个数据模型，其他的网页浏览视图、模板就不做了。 3.1 建立Model在movie/models.py中建立电影数据类， 123456789from django.db import models# Create your models here.class Movie(models.Model): name = models.CharField(max_length=200) year = models.IntegerField() def __str__(self): return f&#x27;&#123;self.name&#125; (&#123;self.year&#125;)&#x27; 对数据模型更改后，要进行迁移 12python manage.py makemigrationspython manage.py migrate 使用python manage.py shell进行项目的shell添加一些数据 12345678910111213&gt;&gt;&gt; from movie.models import Movie&gt;&gt;&gt; Movie.objects.create(name=&quot;The Shawshank Redemption&quot;, year=1994)&lt;Movie: The Shawshank Redemption (1994)&gt;&gt;&gt;&gt; Movie.objects.create(name=&quot;The Godfather&quot;, year=1972)&lt;Movie: The Godfather (1972)&gt;&gt;&gt;&gt; Movie.objects.create(name=&quot;The Dark Knight&quot;, year=2008)&lt;Movie: The Dark Knight (2008)&gt;&gt;&gt;&gt; Movie.objects.create(name=&#x27;The Godfather: Part II&#x27;, year=1974)&lt;Movie: The Godfather: Part II (1974)&gt;&gt;&gt;&gt; Movie.objects.create(name=&#x27;12 Angry Men&#x27;, year=1957)&lt;Movie: 12 Angry Men (1957)&gt;&gt;&gt;&gt; Movie.objects.all()&lt;QuerySet [&lt;Movie: The Shawshank Redemption (1994)&gt;, &lt;Movie: The Godfather (1972)&gt;, &lt;Movie: The Dark Knight (2008)&gt;, &lt;Movie: The Godfather: Part II (1974)&gt;, &lt;Movie: 12 Angry Men (1957)&gt;]&gt; 4. 构建API首先在movie_api/settings.py文件找到INSTALLED_APPS， 注册rest_framework，现在这个列表应该如下， 12345INSTALLED_APPS = [ ... # 其他已有值 &#x27;movie&#x27;, &#x27;rest_framework&#x27;,] 为了避免与网站基本内容混淆，可以项目根目录下建立一个专门的api文件夹，并在其中建立一个空的__init__.py文件，表明这是一个包。 4.1 建立序列化器 我们把变量从内存中变成可存储或传输的过程称之为序列化。——廖雪峰 也就是说，从数据库中把数据读到我们的Model类型的变量中后，还要经过序列化，才能顺利传输到客户端（浏览器），供用户浏览使用。 在api文件夹下建立serializers.py文件，内容如下 1234567from rest_framework import serializersfrom movie.models import Movieclass MovieSerializer(serializers.ModelSerializer): class Meta: model = Movie fields= &#x27;__all__&#x27; 这里建立了一个Movie专用的序列化器，其中序列化的数据包括所有字段。 4.2 建立视图并绑定URL4.2.1 获取所有电影在api文件夹下建立views.py文件 1234567891011from rest_framework.decorators import api_viewfrom movie.models import Moviefrom .serializers import MovieSerializerfrom rest_framework.response import Response@api_view([&#x27;GET&#x27;])def get_movies(request): movies = Movie.objects.all() serializer = MovieSerializer(movies, many=True) return Response(serializer.data) 这里通过装饰器来设置请求方法，这里只是获取，用GET即可。 注意在一个普通的网站中，获取了电影列表后，应该传输给前端的模板，以供渲染，但在API中，我们进行序列化，以供传输。 然后绑定url，在api文件夹下建立urls.py文件， 123456from django.urls import pathfrom . import viewsurlpatterns = [ path(&#x27;&#x27;, views.get_movies, name=&#x27;get_movies&#x27;)] 如文章[[基本Django项目构建]]中提到的，还没有被django项目所识别，因此，需要在movie_api/urls.py文件中进行引用，以让项目进行识别。 123456from django.urls import path, includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;movies/&#x27;, include(&#x27;api.urls&#x27;)),] 这样，运行项目后，我们就可以通过网址http://127.0.0.1:8000/movies/访问电影列表api了，效果如下： 4.2.2 新增电影新增电影条目可以保持与电影列表的网址相同，只需要在视图中增加一个POST请求方法即可。修改api/views.py中相关函数如下， 1234567891011121314from rest_framework import status@api_view([&#x27;GET&#x27;, &#x27;POST&#x27;])def get_movies(request): if request.method == &#x27;GET&#x27;: movies = Movie.objects.all() serializer = MovieSerializer(movies, many=True) return Response(serializer.data) elif request.method == &#x27;POST&#x27;: serializer = MovieSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 要注意的是，一旦数据有变动，要使用is_valid进行数据的验证并使用save保存，这里包括类型、长度等的验证。再次访问网址http://127.0.0.1:8000/movies/，可以看到下方多出了一个输入框，以增加电影条目。 4.2.3 获取某个电影的信息这里也是获取内容，与[[#4 2 1 获取所有电影]]类似，首先在api/views.py中添加视图函数， 12345@api_view([&#x27;PUT&#x27;])def get_movie_detail(request, id): movie = Movie.objects.get(pk=id) serializer = MovieSerializer(movie) return Response(serializer.data) 然后在api/urls.py中绑定网址， 123urlpatterns = [ path(&#x27;&lt;int:id&gt;&#x27;, views.get_movie_detail, name=&#x27;get_movie_detail&#x27;),] 即可通过http://127.0.0.1:8000/movies/1 访问id为1的电影信息了。 4.2.4 修改或删除某个电影的信息修改或删除也是针对某个电影，所以网址与[[#4 2 3 获取某个电影的信息]]可以相同，不过请求方法需要设置为PUT和DELETE，修改相应的视图函数如下： 123456789101112131415@api_view([&#x27;GET&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;])def get_movie_detail(request, id): movie = Movie.objects.get(pk=id) if request.method == &#x27;GET&#x27;: serializer = MovieSerializer(movie) return Response(serializer.data) elif request.method == &#x27;PUT&#x27;: serializer = MovieSerializer(movie, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == &#x27;DELETE&#x27;: movie.delete() return Response(status=status.HTTP_204_NO_CONTENT) 这里增加了对请求方法PUT和DELETE的支持，在函数体中，针对不同的请求类型，有不同的处理。 修改后页面效果如下，可以进行内容的修改和条目的删除。 5. 回顾简单回顾一下，在一个普通的网站项目基础上，首先建立了专门的API文件夹，在其中首先建立序列化器以进行数据转化传输，然后建立了各类视图，并通过不同请求方法进行数据的增、删、改、查（即CRUD操作）API的构建。 可以看到，API的视图函数与一般网站视图函数的主要区别在于，API的视图函数是从数据库获取数据后进行序列化再传输，而一般网站视图函数则是获取数据后传递给前端模板以供展示。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"后端框架","slug":"后端框架","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"api","slug":"api","permalink":"http://example.com/tags/api/"}]},{"title":"1. 基本Django项目构建","slug":"基本Django项目构建","date":"2022-12-31T09:53:37.000Z","updated":"2023-04-26T14:05:40.000Z","comments":true,"path":"2022/12/31/基本Django项目构建/","link":"","permalink":"http://example.com/2022/12/31/%E5%9F%BA%E6%9C%ACDjango%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/","excerpt":"1. 创建django项目可通过如下命令创建名为myproject的django项目，","text":"1. 创建django项目可通过如下命令创建名为myproject的django项目，123django-admin startproject myprojectcd myprojectpython manage.py migrate 备注 python manage.py migrate意思是把数据模型（Python中定义的Model）和数据库同步。 python manage.py makemigrations是当模型的相关代码发生变动时，对变动进行提交保存，后接migrate 2. 创建app1python manage.py startapp base # 这里base就是app的名字 创建完成后要注册app，在setting.py中找到INSTALLED_APPS，加入app名1234INSTALLED_APPS = [ &#x27;base&#x27;, ...] 一个django项目的结构如下 3. 创建数据模型（Model）在models.py中，建立数据模型，类似于pojo，即一个对象包含哪些字段，这也被称为Schema。123456from django.db import models# Create your models here.class Item(models.Model): name = models.CharField(max_length=200) created = models.DateTimeField(auto_now_add=True)如上所述，数据模型变动后，要进行迁移12python manage.py makemigrationspython manage.py migratemakemigrations后，即建立了数据模型和数据库的联系，可以通过python manage.py sqlmigrate base 0001生成sql语句，但这只是供查看确认，并不执行，migrate才是执行。 临时加入数据可以另外开一个shell进行一些操作，比如添加数据1python manage.py shell 这条命令相比直接运行python，可以导入该django项目的环境变量。 在shell中添加数据12345678910111213&gt;&gt;&gt; from base.models import Item&gt;&gt;&gt; Item.objects.create(name=&#x27;item1&#x27;)&lt;Item: Item object (1)&gt;&gt;&gt;&gt; Item.objects.create(name=&#x27;item2&#x27;)&lt;Item: Item object (2)&gt;&gt;&gt;&gt; Item.objects.create(name=&#x27;item3&#x27;)&lt;Item: Item object (3)&gt;&gt;&gt;&gt; items = Item.objects.all()&gt;&gt;&gt; print(items)&lt;QuerySet [&lt;Item: Item object (1)&gt;, &lt;Item: Item object (2)&gt;, &lt;Item: Item object (3)&gt;]&gt;# 也可以这样&gt;&gt;&gt; item = Item(name=&#x27;item4&#x27;)&gt;&gt;&gt; item.save() 4. 创建后端逻辑（View）在views.py文件中完成 比如最简单的，12def home(request): return HttpResponse(&quot;home page&quot;)这样后续执行该逻辑时，网页上就显示了home page这行字。 当然，更一般的，后端会提供一些数据处理，并显示在定义好的前端模板上，这样就要和前端模板绑定。比如现在要把所有的物品显示在前端页面上，那么后端就要从数据库拉取所有的items，123def get_items(request): items = Item.objects.all() return render(request, &#x27;items.html&#x27;, &#123;&#x27;items&#x27;: items&#125;)这样就可以把items数据传递给items.html这个前端模板。 5. 创建前端模板（templates）在base文件夹下创建templates文件夹，再在templates文件夹下创建base文件夹，并在其中新建items.html文件，即base/templates/base/items.html，这样设置后，在django项目中，我们可以通过base/items.html定位到这个模板。 Django框架中存在模板寻找器，可搜索每个app的特定文件夹。 文件内容如下12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Items&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &#123;% for item in items %&#125; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;大意就是把各个物品的名字显示成一个无序列表。 6. 绑定网址以上已经完成了后端与数据库、前端与后端的数据传递，那么用户如何访问这样一个网页呢？就需要在urls.py中绑定好网址和后端。 在base文件夹下新建urls.py文件，内容如下1234567from . import views from django.urls import pathurlpatterns = [ path(&quot;items/&quot;, views.get_items), path(&quot;&quot;, views.home)] 但这个url目前只在base这个app下，并没有被django项目所识别，因此，需要在myproject/urls.py文件中进行引用，以让项目进行识别。123456from django.urls import include # 这是新增的行urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;base/&#x27;, include(&#x27;base.urls&#x27;)) # 这是新增的行] 7. 运行最后，执行python manage.py runserver即可运行网站，打开http://127.0.0.1:8000/base/items/ 就显示了物品列表如下。 8. 参考 Django Crash Course - Introduction + Python Web Development Tutorial Django REST Framework Oversimplified","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"后端框架","slug":"后端框架","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"api","slug":"api","permalink":"http://example.com/tags/api/"}]},{"title":"tmux够用命令","slug":"tmux够用命令","date":"2022-12-31T00:44:10.000Z","updated":"2023-04-26T14:04:50.000Z","comments":true,"path":"2022/12/31/tmux够用命令/","link":"","permalink":"http://example.com/2022/12/31/tmux%E5%A4%9F%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Tmux is a terminal multiplexer for Unix-like systems. It allows users to create and manage multiple terminal sessions within a single terminal window or console. Tmux provides many features that are useful for working in a command-line environment. For example, it allows users to detach and reattach sessions, which means that users can start a session, disconnect from it and then reconnect to it later. This feature is particularly useful for long-running tasks that continue even after the user has logged out or disconnected from the network.","text":"Tmux is a terminal multiplexer for Unix-like systems. It allows users to create and manage multiple terminal sessions within a single terminal window or console. Tmux provides many features that are useful for working in a command-line environment. For example, it allows users to detach and reattach sessions, which means that users can start a session, disconnect from it and then reconnect to it later. This feature is particularly useful for long-running tasks that continue even after the user has logged out or disconnected from the network. 1. Session 会话可以理解为一个连接，tmux其实是提供了一个终端服务，这个服务可以允许我们创建多个终端会话。 1.1 创建匿名和命名的会话12tmux newtmux new -s &lt;session-name&gt; 创建后会自动进入该会话的窗口（下一节详细说明窗口）。 1.2 离开会话1ctrl+b d 即离开当前的会话，回到系统的终端窗口。tmux会话的一大优点是不会随着终端gui的关闭而停止，会话仍保持后台运行，后续可通过attach命令重新进入。 1.3 查看会话列表及进入会话我们可以同时运行多个会话，互不干扰，查看会话列表的命令为1tmux ls第一列就是会话的名字，进入指定会话命令为1tmux attach -t &lt;session-name&gt;这里-t表示target。 1.4 退出会话（删除）1234# 会话内exit# 会话外/内tmux kill-session -t &lt;session-name&gt; 这是彻底退出会话，不会保留后台。 1.5 重命名会话1tmux rename-session -t &lt;session-name&gt; &lt;new-name&gt; 2. Window 窗口每次进入会话看到的都是一个会话窗口，而实际上tmux允许我们在一个session开启多个窗口。 2.1 新窗口1ctrl+b c 这个动作开启了一个新窗口，并自动进入新窗口。可以通过下方状态栏观察。 2.2 窗口跳转那如果我想跳回去之前的窗口，可以通过命令1ctrl+b &lt;window-name&gt; 2.3 窗口重命名这时候我们发现，这些窗口名都是数字，开多了自己都不知道往哪找想要的窗口了，那么，可以把窗口改个容易识别的名字，这样就知道每个窗口在做什么啦。1ctrl+b , 2.4 关闭窗口最后，当不再使用某个窗口，可以关掉1ctrl+d或exit 3. Pane 面板最后的最后，如果你的屏幕足够大，一个窗口只能同时跑一个命令不是很浪费？tmux提供了多面板支持，可以把当前窗口一分为2、3、4…. 3.1 水平划分1ctrl+b % 效果如下 3.2 垂直划分1ctrl+b &quot; 效果如下 当然，水平和垂直划分可以随意组合 3.3 pane间切换这么多面板，怎么跳到指定的那一个，当然不是用鼠标点，我们还是用ctrl+b命令，结合上下左右方向键就可以切换了。 3.4 关闭pane如果觉得太凌乱，就关掉几个pane吧，命令和关窗口一样。 以上。","categories":[{"name":"Shell工具","slug":"Shell工具","permalink":"http://example.com/categories/Shell%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"tmux","slug":"tmux","permalink":"http://example.com/tags/tmux/"}]},{"title":"5. 半正定锥","slug":"半正定锥","date":"2022-04-17T12:19:23.000Z","updated":"2023-04-26T14:05:16.000Z","comments":true,"path":"2022/04/17/半正定锥/","link":"","permalink":"http://example.com/2022/04/17/%E5%8D%8A%E6%AD%A3%E5%AE%9A%E9%94%A5/","excerpt":"1. 几个符号1.1 对称方阵的集合","text":"1. 几个符号1.1 对称方阵的集合 \\mathbf{S}^{n}= \\\\{ X \\in \\mathbf{R}^{n \\times n} \\mid X=X^{T} \\\\}S for symmetric 1.2 对称半正定方阵的集合 \\mathbf{S}^{n}_{+}= \\\\{X \\in \\mathbf{S}^{n} \\mid X \\succeq 0 \\\\}$\\succeq$表示矩阵的特征值$\\ge 0$ 1.3 对称正定方阵的集合 \\mathbf{S}^{n}_{++}= \\\\{X \\in \\mathbf{S}^{n} \\mid X \\succ 0 \\\\}1.4 证明对称半正定方阵为凸锥半正定矩阵有： x^TAx \\ge 0代入凸锥的定义即可证 x^{T}\\left(\\theta_{1} A+\\theta_{2} B\\right) x=\\theta_{1} x^{T} A x+\\theta_{2} x^{T} B x \\geq 01.5 对比 $\\mathbf{S}^{n}$、$\\mathbf{S}^{n}_+$是凸锥（当然也是凸集）； $\\mathbf{S}^{n}_{++}$是凸集，不是凸锥，因为不包含0点。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"http://example.com/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://example.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"4. 多面体和单纯形","slug":"多面体和单纯形","date":"2022-04-17T12:16:41.000Z","updated":"2023-04-26T14:06:04.000Z","comments":true,"path":"2022/04/17/多面体和单纯形/","link":"","permalink":"http://example.com/2022/04/17/%E5%A4%9A%E9%9D%A2%E4%BD%93%E5%92%8C%E5%8D%95%E7%BA%AF%E5%BD%A2/","excerpt":"1. 多面体(Polyhedron)多面体是一系列线性等式和不等式的解集。","text":"1. 多面体(Polyhedron)多面体是一系列线性等式和不等式的解集。 \\mathcal{P}=\\\\{x \\mid a_{j}^{T} x \\leq b_{j}, j=1, \\ldots, m, c_{j}^{T} x=d_{j}, j=1, \\ldots, p\\\\}向量形式为 \\mathcal{P}= \\\\{x \\mid A x \\preceq b, C x=d \\\\}从定义可以看出，多面体就是超平面和半空间的交集。 有界的多面体称为Polytope。 2. 单纯形(Simplex)2.1 定义假设$k+1$个点$v_0, \\ldots, v_k \\in R^n$仿射独立，即$v_1-v_0, \\ldots, v_k-v_0$线性不相关，则与这$k+1$个点相关的单纯形 即为这些点的凸包： \\begin{align} C & = \\operatorname{conv}\\\\{v_{0}, \\ldots, v_{k}\\\\} \\\\ & = \\\\{\\theta_{0} v_{0}+\\cdots+\\theta_{k} v_{k} \\mid \\theta \\succeq 0, \\mathbf{1}^{T} \\theta = 1\\\\} \\end{align}2.2 例子以二维空间为例 若给两个不同的点，则构成的单纯形为一条线段 若给三个不同的点，则构成的单纯形为一个三角形 若给四个以上不同的点，则不可能仿射独立，不能构成单纯形 2.3 证明单纯形是多面体思路： 把单纯形中的点表示成多面体的形式 线性不相关-&gt;满秩 设单纯形为$C$，则$C$中的点可表示为 x=\\theta_{0} v_{0}+\\theta_{1} v_{1}+\\cdots+\\theta_{k} v_{k}其中$\\theta \\succeq 0, \\mathbf{1}^{T} \\theta = 1$，要注意的是$\\theta$是可变的，决定了$x$的取值。对上式进行变换，得 \\begin{align} x &= v_{0}+\\theta_{1} (v_{1}-v_{0})+\\cdots+\\theta_{k} (v_{k}-v_{0})\\\\ &=v_0 +By \\end{align}其中 \\begin{align} B & = \\left[\\begin{array}{lll} v_{1}-v_{0} & \\cdots & v_{k}-v_{0} \\end{array}\\right] \\in \\mathbf{R}^{n \\times k}\\\\ y & = \\left(\\theta_{1}, \\ldots, \\theta_{k}\\right) \\end{align}注意这里的$y$不是$\\theta$，少了一个元素。$y \\succeq 0,\\mathbf{1}^{T} y \\le 1$。显然可以用$y$的约束条件来得到对$x$的约束，那么下一步要做的就是把$y$独立出来。 由于$B$中各向量线性无关，则$rank(B)=k$，因此，存在非奇异矩阵$A=(A_1, A_2) \\in R^{n \\times n}$使得， A B=\\left[\\begin{array}{l} A_{1} \\\\ A_{2} \\end{array}\\right] B=\\left[\\begin{array}{l} I \\\\ 0 \\end{array}\\right]在$x$的表达式左边乘上矩阵$A$，可得 A_{1} x=A_{1} v_{0}+y, \\quad A_{2} x=A_{2} v_{0}代入$y$的约束，可得 A_{2} x=A_{2} v_{0}, \\quad A_{1} x \\succeq A_{1} v_{0}, \\quad \\mathbf{1}^{T} A_{1} x \\leq 1+\\mathbf{1}^{T} A_{1} v_{0}符合多面体的定义，证毕。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"http://example.com/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://example.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"3. 球和椭球","slug":"球和椭球","date":"2022-04-17T05:49:31.000Z","updated":"2023-04-26T14:06:24.000Z","comments":true,"path":"2022/04/17/球和椭球/","link":"","permalink":"http://example.com/2022/04/17/%E7%90%83%E5%92%8C%E6%A4%AD%E7%90%83/","excerpt":"1. 球(Ball)1.1 定义球有两种形式的定义","text":"1. 球(Ball)1.1 定义球有两种形式的定义 1.1.1 定义一 \\begin{align} B\\left(x_{c}, r\\right) & = \\\\{x \\mid\\left\\|x-x_{c}\\right\\|_{2} \\leq r\\\\}\\\\& = \\\\{x \\mid\\left(x-x_{c}\\right)^{T}\\left(x-x_{c}\\right) \\leq r^{2}\\\\} \\end{align}其中$x_c$为球心，$r$为半径。 1.1.2 定义二B\\left(x_{c}, r\\right)=\\\\{x_{c}+r u \\mid\\|u\\|_{2} \\leq 1\\\\}从直观上看，我们都知道球一定是个凸集。下面分别通过两种定义进行证明： 1.2 球为凸集的证明1.2.1 利用定义一证明 \\begin{aligned} \\|\\theta x_{1}+(1-\\theta) x_{2}-x_{c}\\|_{2} &=\\|\\theta (x_{1}-x_{c} )+(1-\\theta) (x_{2}-x_{c} ) \\|_{2} \\\\ & \\leq \\theta \\|x_{1}-x_{c} \\|_{2}+(1-\\theta) \\|x_{2}-x_{c} \\|_{2} \\\\ & \\leq r . \\end{aligned}这里关键就是用到了三角不等式 1.2.2 利用定义二证明 \\theta(x_c+ru_1)+(1-\\theta)(x_c+ru_2)=x_c+r\\left(\\theta u_1+(1-\\theta)u_2\\right)那么只需要保证 \\|\\theta u_1+(1-\\theta)u_2\\|_{2} \\le 1同样用三角不等式容易证明。 2. 椭球(Ellipsoid)2.1 定义同样，也有两种定义形式 2.1.1 定义一 \\mathcal{E}=\\\\{x \\mid\\left(x-x_{c}\\right)^{T} P^{-1}\\left(x-x_{c}\\right) \\leq 1\\\\}其中$P=P^{T} \\succ 0$，即对称且正定。椭球的半轴就是矩阵$P$的特征值的方根。 特别地，当$P=r^2 I$，该点集为一个半径为$r$的球。 2.1.2 定义二 \\mathcal{E}=\\\\{x_{c}+A u \\mid\\|u\\|_{2} \\leq 1\\\\}这里$A=P^{1/2}$。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"http://example.com/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://example.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"2. 超平面和半空间","slug":"超平面和半空间","date":"2022-04-17T05:47:34.000Z","updated":"2023-04-26T14:06:30.000Z","comments":true,"path":"2022/04/17/超平面和半空间/","link":"","permalink":"http://example.com/2022/04/17/%E8%B6%85%E5%B9%B3%E9%9D%A2%E5%92%8C%E5%8D%8A%E7%A9%BA%E9%97%B4/","excerpt":"1. 超平面(hyperplane)形如$\\{x \\mid a^Tx=b \\}(a \\ne 0)$的就是超平面","text":"1. 超平面(hyperplane)形如$\\{x \\mid a^Tx=b \\}(a \\ne 0)$的就是超平面可以看成是一系列点的集合，这些点与向量$a$的内积为一个固定的常数。而$b$则是该超平面相对于原点的偏移量，原定义可以写作 \\{ x \\mid a^T(x-x_0)=0 \\}其中$x_0$为超平面上一点。 2. 半空间(halfspace)超平面可以把$R^n$分割为两个半空间，形如$\\{x \\mid a^Tx \\le b \\}(a \\ne 0)$的就是半空间用定义可证，半空间也是一个凸集（[[1. 仿射集-凸集-凸锥#凸集 convex set]]） 3. 子空间(subspace)要区分子空间和半空间。所谓子空间，或者空间，即存在以下性质的点集合：对于$x_1, x_2 \\in V$，有 \\alpha x_1 + \\beta x_2 \\in V, \\quad \\alpha,\\beta \\in R","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"http://example.com/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://example.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"批量爬取大学课件","slug":"批量爬取大学课件","date":"2022-04-16T01:36:22.000Z","updated":"2023-04-26T14:06:14.000Z","comments":true,"path":"2022/04/16/批量爬取大学课件/","link":"","permalink":"http://example.com/2022/04/16/%E6%89%B9%E9%87%8F%E7%88%AC%E5%8F%96%E5%A4%A7%E5%AD%A6%E8%AF%BE%E4%BB%B6/","excerpt":"国外很多大学的课件放在一个专门的页面上，如下图所示，那么很容易通过一个爬虫批量下载下来。 思路就是识别页面中以pdf结尾的链接，然后进行下载。","text":"国外很多大学的课件放在一个专门的页面上，如下图所示，那么很容易通过一个爬虫批量下载下来。 思路就是识别页面中以pdf结尾的链接，然后进行下载。 单线程版本123456789101112131415import requestsfrom bs4 import BeautifulSoupurl = &#x27;https://inst.eecs.berkeley.edu/~ee127/fa19/Lectures/&#x27;page = requests.get(url).contentsoup = BeautifulSoup(page, &#x27;html.parser&#x27;)links = soup.find_all(&#x27;a&#x27;)for link in links: href = link.get(&#x27;href&#x27;) if href.endswith(&#x27;.pdf&#x27;): file_url = url + href with open(href, &#x27;wb&#x27;) as f: f.write(requests.get(file_url).content) 下载25个文件，费时180秒左右。 多线程版本对于这种国外网站，常常下载速度较慢，这种IO密集型的任务使用多线程就非常有必要了。123456789101112131415161718192021222324from threading import Threadimport requestsfrom bs4 import BeautifulSoupdef download(url, href): r = requests.get(url + href) with open(href, &#x27;wb&#x27;) as f: f.write(r.content)url = &#x27;https://inst.eecs.berkeley.edu/~ee127/fa19/Lectures/&#x27;page = requests.get(url).contentsoup = BeautifulSoup(page, &#x27;html.parser&#x27;)links = soup.find_all(&#x27;a&#x27;)threads = []for link in links: href = link.get(&#x27;href&#x27;) if href.endswith(&#x27;.pdf&#x27;): t = Thread(target=download, args=(url, href)) threads.append(t) t.start()for t in threads: t.join()这时，下载同样的文件，只需12秒左右，效果还是很明显的。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"1. 仿射集、凸集、凸锥","slug":"仿射集 凸集 凸锥","date":"2022-04-16T00:44:10.000Z","updated":"2023-04-26T14:05:06.000Z","comments":true,"path":"2022/04/16/仿射集 凸集 凸锥/","link":"","permalink":"http://example.com/2022/04/16/%E4%BB%BF%E5%B0%84%E9%9B%86%20%E5%87%B8%E9%9B%86%20%E5%87%B8%E9%94%A5/","excerpt":"1. 仿射集(affine set)1.1 直线(line)","text":"1. 仿射集(affine set)1.1 直线(line) 通过两个点$x_1 \\ne x_2$，可构造一条直线 y=\\theta x_1 + (1-\\theta) x_2其中$\\theta \\in R$。若令$\\theta \\in [0,1]$，则为一条线段。这个式子可以简单变换为 y=x_2 + \\theta(x_1 - x_2)表示以$x_2$为基准点，向$x_1-x_2$方向构造的一系列新的点。 把$\\theta$看作变量，上式其实就是对$\\theta$的线性变换加上一个常数，这就是仿射.（仿射变换，又称仿射映射，是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。） 1.2 仿射组合(affine combination)给定若干点$x_i(i=1,\\ldots,k)$，定义 y=\\theta_1 x_1 + \\theta_2 x_2 + \\cdots + \\theta_k x_k为这些点的仿射组合。其中$\\theta_i \\in R$ 且$\\theta_1 + \\theta_2 + \\cdots + \\theta_k=1$。 1.3 仿射集(affine set)一个集合$C$被称为仿射集，其充分条件是“经过其中任意两点的直线仍在此集合中”。即对任意$x_1, x_2 \\in C$， y=\\theta x_1 + (1-\\theta) x_2也在集合$C$中，其中$\\theta \\in R$，则$C$为仿射集。 设$x_0 \\in C$，则 V=C-x_0=\\left\\{x-x_0 | x \\in C\\right\\}是一个与C相关的[[子空间(subspace)]] 例子1线性方程组$\\{x \\mid A x=b\\}$的解集$C$一定是仿射集。反之，每个仿射集都可以表示为一个线性方程组的解集。根据定义，$C$对应的子空间为$\\{x \\mid A x=0\\}$，即$A$的化零空间(nullspace)。 1.4 仿射包(affine hull)任意集合$C$，构造尽可能小的仿射集。即集合$C$中所有点的仿射组合称为关于$C$的仿射包（$\\text { aff } C$，包是指包含、包裹之意）。 \\text { aff } C=\\left\\{\\theta_{1} x_{1}+\\cdots+\\theta_{k} x_{k} \\mid x_{1}, \\ldots, x_{k} \\in C, \\theta_{1}+\\cdots+\\theta_{k}=1\\right\\}2. 凸集(convex set)2.1 凸组合(convex combination)给定若干点$x_i(i=1,\\ldots,k)$，定义 y=\\theta_1 x_1 + \\theta_2 x_2 + \\cdots + \\theta_k x_k其中$\\theta_i \\ge 0$ 且$\\theta_1 + \\theta_2 + \\cdots + \\theta_k=1$，$y$称作$x_1, x_2, \\ldots, x_k$的一个凸组合。 2.2 凸集(convex set)一个集合$C$被称为凸集，其充分条件是“经过其中任意两点的线段仍在此集合中”。即对任意$x_1, x_2 \\in C$， y=\\theta x_1 + (1-\\theta) x_2也在集合$C$中，其中$\\theta \\in [0,1]$，则$C$为凸集。可见，凸集的要求比仿射集低，任何仿射集都是凸集。 2.3 凸包(convex hull)对任意集合$C$，集合$C$中所有点的凸组合称为凸包，可记作$\\operatorname{conv} C$。 \\operatorname{conv} C=\\left\\{\\theta_{1} x_{1}+\\cdots+\\theta_{k} x_{k} \\mid x_{i} \\in C, \\theta_{i} \\geq 0, i=1, \\ldots, k, \\theta_{1}+\\cdots+\\theta_{k}=1\\right\\}3. 凸锥(convex cone)3.1 锥(cone)对于集合$C$中任意点$x$和任意常数$\\theta \\ge 0$，都有$\\theta x \\in C$，则$C$称为锥。 注： 一条任意射线不一定是锥 一条端点在0点的射线是锥 两条端点在0点的射线是锥 3.2 锥组合(conic combination)简单理解，conic 就是非负（或者单边）的意思。给定若干点$x_i(i=1,\\ldots,k)$，定义 y=\\theta_1 x_1 + \\theta_2 x_2 + \\cdots + \\theta_k x_k其中$\\theta_i \\ge 0$ ，$y$称作$x_1, x_2, \\ldots, x_k$的一个锥组合。 3.3 凸锥(convex cone)若从凸锥组合仍属于原集合，则称为凸锥。即对任意$x_1, x_2 \\in C$， y=\\theta_1 x_1 + \\theta_2 x_2也在集合$C$中，其中$\\theta_i \\ge 0$，则$C$为凸锥。显然，凸锥的要求包含对凸集的要求，任何凸锥都是凸集。 注： 两条端点在0点的射线不是凸锥 两条端点在0点的射线及其构成的扇形区域是凸锥 3.4 锥包(conic hull)对任意集合$C$，集合$C$中所有点的锥组合称为锥包。 \\left\\{\\theta_{1} x_{1}+\\cdots+\\theta_{k} x_{k} \\mid x_{i} \\in C, \\theta_{i} \\geq 0, i=1, \\ldots, k\\right\\}4. 特殊集合对比4.1 点一个点一定是仿射集和凸集，但不一定是锥，只有原点可以单独构成一个凸锥。 4.2 空集空集既是仿射集，又是凸集和凸锥。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"http://example.com/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"http://example.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]}],"categories":[{"name":"优化","slug":"优化","permalink":"http://example.com/categories/%E4%BC%98%E5%8C%96/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Shell工具","slug":"Shell工具","permalink":"http://example.com/categories/Shell%E5%B7%A5%E5%85%B7/"},{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"http://example.com/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"pulp","slug":"pulp","permalink":"http://example.com/tags/pulp/"},{"name":"solver","slug":"solver","permalink":"http://example.com/tags/solver/"},{"name":"mip","slug":"mip","permalink":"http://example.com/tags/mip/"},{"name":"cython","slug":"cython","permalink":"http://example.com/tags/cython/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"后端框架","slug":"后端框架","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"api","slug":"api","permalink":"http://example.com/tags/api/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"tmux","slug":"tmux","permalink":"http://example.com/tags/tmux/"},{"name":"凸优化","slug":"凸优化","permalink":"http://example.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]}