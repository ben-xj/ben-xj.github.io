{"meta":{"title":"10天行不行","subtitle":"","description":"","author":"10天行不行","url":"https://ben-xj.github.io","root":"/"},"pages":[{"title":"about","date":"2022-04-16T01:13:47.000Z","updated":"2023-07-22T08:36:06.000Z","comments":true,"path":"about/index.html","permalink":"https://ben-xj.github.io/about/index.html","excerpt":"","text":"足迹 本科(2015-2019) —— 上海交通大学 硕士(2019-2022) —— 上海交通大学 算法工程师(2022- ) —— hidden content 个人频道 抖音号：48193505948 B站：10天行不行 YouTube：10天行不行 西瓜视频：10天行不行 TG群组：https://t.me/+v4GY6wMx_ctiM2M1 TG频道：https://t.me/is_ten_days_enough"},{"title":"categories","date":"2022-04-15T18:16:09.000Z","updated":"2022-04-16T01:01:24.000Z","comments":true,"path":"categories/index.html","permalink":"https://ben-xj.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-04-15T18:16:34.000Z","updated":"2022-04-15T18:19:34.000Z","comments":true,"path":"friends/index.html","permalink":"https://ben-xj.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-15T18:16:20.000Z","updated":"2022-04-16T01:01:36.000Z","comments":true,"path":"tags/index.html","permalink":"https://ben-xj.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入浅出Python生成器","slug":"Python生成器","date":"2023-07-22T08:26:21.000Z","updated":"2023-07-22T08:28:04.000Z","comments":true,"path":"2023/07/22/Python生成器/","link":"","permalink":"https://ben-xj.github.io/2023/07/22/Python%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"Understanding Python Generators and Efficient Sequences Introduction Python’s generators are a powerful feature that allows developers to create memory-efficient and lazy-evaluated sequences. Unlike regular sequences, such as lists, generators produce values on-the-fly, making them ideal for processing large datasets or infinite sequences. In this article, we will explore the concept of generators in Python, how to create them using generator functions and comprehensions, and understand their benefits over traditional sequences.","text":"Understanding Python Generators and Efficient Sequences Introduction Python’s generators are a powerful feature that allows developers to create memory-efficient and lazy-evaluated sequences. Unlike regular sequences, such as lists, generators produce values on-the-fly, making them ideal for processing large datasets or infinite sequences. In this article, we will explore the concept of generators in Python, how to create them using generator functions and comprehensions, and understand their benefits over traditional sequences. 1. What are Generators? Generators are a special type of iterable in Python that use lazy evaluation to generate values one at a time. They are defined using functions that contain the yield keyword. When a generator function is called, it returns a generator object without executing the entire function body. Instead, the values are generated only when requested through iteration. 2. Generator Functions Generator functions are the primary method of creating generators. By defining a function with the yield keyword, we can produce values on-the-fly, reducing memory consumption and improving performance. Here’s an example of a generator function that yields squares of numbers: 1234def squares_generator(limit): for i in range(1, limit + 1): yield i ** 2 Usage: 1234567# Create the generatorgen = squares_generator(5)# Iterate over the generator and print the squaresfor square in gen: print(square) Output: 123451491625 3. Using Generators We can utilize generators in various ways. For instance, we can iterate over them using a for loop, access elements using next(), or convert them into a list using list(). Since generators yield elements on demand, they are more memory-efficient and faster for large datasets. Usage: 1234567891011# Create the generatorgen = squares_generator(5)# Using next() to access elements one by oneprint(next(gen)) # Output: 1print(next(gen)) # Output: 4# Convert the generator to a listsquare_list = list(gen)print(square_list) # Output: [9, 16, 25] 4. Generator Comprehensions Similar to list comprehensions, Python offers generator comprehensions using parentheses instead of square brackets. Generator comprehensions allow us to create generators in a more concise and readable manner. Here’s an example: 123# Create a generator for even numbers from 1 to 10even_numbers_gen = (x for x in range(1, 11) if x % 2 == 0) Usage: 1234# Iterate over the generator and print the even numbersfor even_number in even_numbers_gen: print(even_number) Output: 12345246810 5. Infinite Series with Generators Generators shine when dealing with infinite sequences, such as the Fibonacci series. Since generators produce values on-the-fly, they can generate an infinite sequence without consuming excessive memory. For example: 123456def fibonacci_generator(): a, b = 0, 1 while True: yield a a, b = b, a + b Usage: 1234567# Create the Fibonacci generatorfib_gen = fibonacci_generator()# Print the first 10 Fibonacci numbersfor _ in range(10): print(next(fib_gen)) Output: 123456789100112358132134 6. Differences between range and Generators Although the range function in Python is often used in loops, it does not return a generator by default. However, you can convert a range object into a generator using generator comprehensions or the iter() function. While range objects are efficient for representing ranges of integers, generators are more flexible and memory-efficient for handling dynamic or infinite sequences. Conclusion Python generators offer an elegant and memory-efficient approach to deal with sequences, especially when working with large datasets or infinite series. They are defined using generator functions or comprehensions, allowing developers to produce values on-the-fly as they are needed. By leveraging generators in your Python code, you can optimize memory consumption and improve the performance of your applications. Understanding generators is a valuable skill for any Python developer looking to handle data streams or create efficient sequences in their programs.","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"generator","slug":"generator","permalink":"https://ben-xj.github.io/tags/generator/"}]},{"title":"Linux/Unix常用命令: grep","slug":"Grep","date":"2023-05-16T12:10:08.000Z","updated":"2023-05-16T12:34:44.000Z","comments":true,"path":"2023/05/16/Grep/","link":"","permalink":"https://ben-xj.github.io/2023/05/16/Grep/","excerpt":"grep是Linux/Unix系统中非常常用的命令，它用来在文本文件中查找指定的模式并输出文本行。 以下均以or-tools文件夹中的 Dependencies.txt文件为例，其内容如下:","text":"grep是Linux/Unix系统中非常常用的命令，它用来在文本文件中查找指定的模式并输出文本行。 以下均以or-tools文件夹中的 Dependencies.txt文件为例，其内容如下: 1234567891011Protobuf=v21.12abseil-cpp=20230125.0Cbc=2.10.7Cgl=0.60.5Clp=1.17.7Clp=1.17.7Osi=0.108.7CoinUtils=2.11.6Eigen=3.4.0Re2=2021-11-01Scip=v803 以下是grep命令的常用用法： 0. 递归查找 1grep -r pattern directory 使用-r选项可以递归查找指定目录下所有文件，而不仅仅是当前目录。 例：我们在or-tools外层文件夹中执行以下命令： 1grep -r Clp=1.17.7 or-tools/ 即可找到Clp=1.17.7出现的两行。 接下来我们进入or-tools文件夹，直接对Dependencies.txt文件进行操作。 1. 简单模式匹配 1grep pattern file 这个最简单的用法，会在指定的文件中查找匹配pattern的所有行。 例：我们找到所有包含Clp的行。 1grep Clp Dependencies.txt 2. 忽略大小写匹配 1grep -i pattern file 使用-i选项可以忽略大小写来查找匹配。 例：我们找到所有包含clp的行，忽略大小写。 1grep -i clp Dependencies.txt 3. 显示匹配行数 1grep -c pattern file 使用-c选项可以统计匹配的行数。 例：我们统计一下Clp出现的次数。 1grep -c Clp Dependencies.txt 不同的选项可以组合使用，比如我们可以忽略大小写，统计一下clp出现的次数。 1grep -ci clp Dependencies.txt 4. 输出不匹配的行 1grep -v pattern file 使用-v选项可以输出不匹配pattern的所有行。 例：我们输出一下不包含Clp的行。 1grep -v Clp Dependencies.txt 5. 输出匹配行的前后若干行 1grep -A n -B m pattern file 使用-A和-B选项可以输出匹配pattern的行的前后n和m行。而-C选项则可以输出前后n行。 例：我们输出一下包含Clp的行的前后一行。 1grep -A 1 -B 1 Clp Dependencies.txt 还有很多其他选项和使用方法，可以通过 man grep命令查看更多帮助和用法。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ben-xj.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ben-xj.github.io/tags/linux/"},{"name":"grep","slug":"grep","permalink":"https://ben-xj.github.io/tags/grep/"}]},{"title":"Powering Up Your Code: Parallel Programming with three Python packages","slug":"python parallel tools","date":"2023-05-05T13:44:10.000Z","updated":"2023-05-14T14:15:48.000Z","comments":true,"path":"2023/05/05/python parallel tools/","link":"","permalink":"https://ben-xj.github.io/2023/05/05/python%20parallel%20tools/","excerpt":"Introduction Parallel computing is a crucial aspect of modern-day computing that enables programs to perform computations faster and more efficiently. Python has several libraries that allow developers to write parallel programs, including Joblib, Ray, and Multiprocessing. In this blog post, we will explore the usage of these libraries and how they can help write efficient parallel programs.","text":"Introduction Parallel computing is a crucial aspect of modern-day computing that enables programs to perform computations faster and more efficiently. Python has several libraries that allow developers to write parallel programs, including Joblib, Ray, and Multiprocessing. In this blog post, we will explore the usage of these libraries and how they can help write efficient parallel programs. Choice 1: Joblib Joblib is a Python library that allows for easy parallelization of CPU-bound tasks. It provides a simple and lightweight interface to parallelize functions using threads or processes. Joblib is easy to use and requires no prior knowledge of multi-processing. To use Joblib, you need to import the Parallel and delayed functions from the joblib module. The Parallel function is used to create a parallel object, and the delayed function is used to specify which function to parallelize. Here is an example: 1234567891011from joblib import Parallel, delayedimport time def compute_square(n): time.sleep(1) return n ** 2if __name__ == &#x27;__main__&#x27;: inputs = range(10) results = Parallel(n_jobs=2)(delayed(compute_square)(i) for i in inputs) print(results) In the example above, we define a function compute_square that takes an input and returns its square. We then use Joblib’s Parallel function to create a parallel object with two parallel jobs and apply it to the compute_square function using the delayed function. Finally, we print the results. Also, joblib supports several backends for parallel processing. Here are some of the available backends for joblib Parallel: “loky” - The default backend that is recommended for most users. It uses the “Loky” process-based backend and allows for inter-process communication. “threading” - This backend uses Python’s built-in threading module to run tasks in parallel. “multiprocessing” - This backend uses Python’s built-in multiprocessing module, which spawns new processes to execute tasks in parallel. “dask” - This backend uses the Dask library to distribute tasks across multiple nodes in a cluster or on a single machine. “ray” - This backend uses the Ray library to parallelize functions across multiple cores or multiple machines. Choice 2: Ray Ray is a powerful Python library for building distributed applications. It makes it easy to parallelize Python code across multiple CPUs or GPUs. Ray provides a simple to use API for parallelizing embarrassingly parallel and data-intensive workloads. To use Ray, you need to import the ray module and use the ray.remote decorator to decorate a function that you want to parallelize. When you call the function, Ray will automatically create a worker process to execute the function. Here is an example: 1234567891011121314import rayimport timeray.init()@ray.remotedef compute_square(n): time.sleep(1) return n ** 2if __name__ == &#x27;__main__&#x27;: inputs = [1, 2, 3, 4, 5] results = ray.get([compute_square.remote(i) for i in inputs]) print(results) In the example above, we define a compute_square function that will sleep for one second and return the square of an input number. We use the @ray.remote decorator to specify that the function is going to be executed remotely. In the main block, we call the remote function using the ray.get method, and finally, we print the results. Choice 3: Multiprocessing Multiprocessing is a Python library that allows developers to write parallel programs using processes. It provides a simple and easy-to-use interface to spawn multiple processes to take advantage of multi-core CPUs. To use Multiprocessing, you need to import the multiprocessing module, and then create a Process object for each process you want to spawn. In each Process object, you pass the function you want to execute, along with its arguments. Here is an example: 1234567891011121314151617181920212223from multiprocessing import Processfrom multiprocessing import Valueimport timedef compute_square(n, result: Value): time.sleep(1) result = n**2if __name__ == &#x27;__main__&#x27;: inputs = [1, 2, 3, 4, 5] results = [Value(&#x27;f&#x27;, 0.) for i in range(5)] processes = [ Process(target=compute_square, args=(inputs[i], results[i])) for i in range(5) ] for p in processes: p.start() for p in processes: p.join() print([v.value for v in results]) In the example above, we define a compute_square function that will sleep for one second and return the square of an input number. In the main block, we create a Process object for each input number, and then we start each process using the start method. Finally, we wait for all processes to complete using the join method. Conclusion In this blog post, we explored three Python libraries, Joblib, Ray, and Multiprocessing that you can use to write parallel programs in Python. These libraries provide a simple and easy-to-use interface to parallelize computations, which can help you write programs that run faster and more efficiently. When deciding which library to use, it’s essential to consider the type of program you’re writing and the specific requirements of your application.","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"parallel programming","slug":"parallel-programming","permalink":"https://ben-xj.github.io/tags/parallel-programming/"},{"name":"joblib","slug":"joblib","permalink":"https://ben-xj.github.io/tags/joblib/"},{"name":"ray","slug":"ray","permalink":"https://ben-xj.github.io/tags/ray/"},{"name":"multiprocessing","slug":"multiprocessing","permalink":"https://ben-xj.github.io/tags/multiprocessing/"}]},{"title":"MapStruct and Lombok not working together","slug":"MapStruct-and-Lombok-not-working-together","date":"2023-05-05T12:49:56.000Z","updated":"2023-05-05T13:14:08.000Z","comments":true,"path":"2023/05/05/MapStruct-and-Lombok-not-working-together/","link":"","permalink":"https://ben-xj.github.io/2023/05/05/MapStruct-and-Lombok-not-working-together/","excerpt":"Problem When attempting to learn mapstruct as a new tool, I discovered that it does not seamlessly integrate with lombok annotations such as @AllArgsConstructor, as it suggests that the constructor does not exist. However, once I manually create the constructor, everything operates as intended. Clearly, the lombok annotation is not functioning as expected.","text":"Problem When attempting to learn mapstruct as a new tool, I discovered that it does not seamlessly integrate with lombok annotations such as @AllArgsConstructor, as it suggests that the constructor does not exist. However, once I manually create the constructor, everything operates as intended. Clearly, the lombok annotation is not functioning as expected. Cause The reason why it does not work is because Maven only uses the MapStruct processor and not the Lombok one. The annotationProcessorPaths tells maven which processors it should use. Simple solution: add maven dependency: Don’t forget the lombok-mapstruct-binding dependency 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.26&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt; add necessary annotation processor paths to maven plugin: add lombok related paths 123456789101112131415161718192021222324252627&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- depending on your project --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- depending on your project --&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;!-- other annotation processors --&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.26&lt;/version&gt; &lt;/path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/plugin&gt; And, voila! Everything’s working fine now. ref https://stackoverflow.com/questions/47676369/mapstruct-and-lombok-not-working-together","categories":[{"name":"Java","slug":"Java","permalink":"https://ben-xj.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ben-xj.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"https://ben-xj.github.io/tags/lombok/"},{"name":"mapstruct","slug":"mapstruct","permalink":"https://ben-xj.github.io/tags/mapstruct/"},{"name":"maven","slug":"maven","permalink":"https://ben-xj.github.io/tags/maven/"}]},{"title":"pip包管理基本使用","slug":"pip包管理","date":"2023-04-29T14:06:56.000Z","updated":"2023-04-29T14:13:00.000Z","comments":true,"path":"2023/04/29/pip包管理/","link":"","permalink":"https://ben-xj.github.io/2023/04/29/pip%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"","text":"1. 镜像加速 在我们使用pip进行Python包安装时，如果我们需要使用镜像站来加速下载和安装，可以执行以下命令： 1.1 临时使用 1pip install -i https://mirrors.sjtug.sjtu.edu.cn/pypi/web/simple some-package 需要注意的是，simple不能少，而且是https而不是http。 1.2 长期使用 如果我们希望将该镜像站设为默认的源地址，可以先升级pip到最新版本，然后执行以下命令： 12pip install pip -Upip config set global.index-url https://mirrors.sjtug.sjtu.edu.cn/pypi/web/simple 如果我们连接pip默认源的网络连接较差，也可以使用以下命令临时使用这个镜像站来升级pip： 1pip install -i https://mirrors.sjtug.sjtu.edu.cn/pypi/web/simple pip -U 2. 依赖导入和导出 在Python项目中，我们通常会使用多个第三方包，这些包可以通过pip进行安装。而在开发过程中，我们可能需要将当前环境中的所有包信息导出到文件中，或从文件中读取所有包信息并安装这些包。 我们可以使用以下两个命令来实现这个功能： 将当前环境中的所有包信息输出到文件中： 1pip freeze &gt; requirements.txt 使用一个文件安装所有包信息： 1pip install -r requirements.txt 通过这两个命令，我们可以更方便地管理第三方包，提高项目开发的效率。","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"pip","slug":"pip","permalink":"https://ben-xj.github.io/tags/pip/"}]},{"title":"From C++ to Python: How to Use Pybind11 for Cross-Language Interoperability","slug":"pybind11 basic","date":"2023-04-29T12:44:10.000Z","updated":"2023-04-29T13:13:42.000Z","comments":true,"path":"2023/04/29/pybind11 basic/","link":"","permalink":"https://ben-xj.github.io/2023/04/29/pybind11%20basic/","excerpt":"Introduction Pybind11 is a lightweight header-only library that allows you to expose C++ functions and classes to Python. It simplifies the process of creating Python bindings for C++ code and allows seamless interoperability between C++ and Python. In this article, we will discuss how to use Pybind11 to use C++ functions and classes in Python with a runnable example code.","text":"Introduction Pybind11 is a lightweight header-only library that allows you to expose C++ functions and classes to Python. It simplifies the process of creating Python bindings for C++ code and allows seamless interoperability between C++ and Python. In this article, we will discuss how to use Pybind11 to use C++ functions and classes in Python with a runnable example code. Prerequisites To follow along with this article, you should have: Basic knowledge of C++ and Python Basic knowledge of Python’s C API Installation Pybind11 can be installed via pip by running the following command: 1pip install pybind11 If you prefer to install Pybind11 manually, you can download it from GitHub and build it using CMake. Example Let’s say we have a simple C++ class called Calculator that has two member functions add and subtract: 12345678910class Calculator &#123;public: Calculator() &#123;&#125; int add(int x, int y) &#123; return x + y; &#125; int subtract(int x, int y) &#123; return x - y; &#125;&#125;; We would like to create a Python wrapper for this class so that we can use it in Python. Here’s how we can do this using Pybind11: 1234567891011121314151617181920#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;class Calculator &#123;public: Calculator() &#123;&#125; int add(int x, int y) &#123; return x + y; &#125; int subtract(int x, int y) &#123; return x - y; &#125;&#125;;PYBIND11_MODULE(calculator, m) &#123; pybind11::class_&lt;Calculator&gt;(m, &quot;Calculator&quot;) .def(pybind11::init&lt;&gt;()) .def(&quot;add&quot;, &amp;Calculator::add) .def(&quot;subtract&quot;, &amp;Calculator::subtract);&#125; Explanation Let’s break down this code. We start by including the pybind11 header file. Then, we define our Calculator class as before. Next, we use the PYBIND11_MODULE macro to create a Python module called calculator. This macro takes two arguments: the name of the module and an instance of pybind11::module class that represents the module. In this case, we define the module as m. We then use the pybind11::class_ template to define the Calculator class as a Python class. The first argument to pybind11::class_ is the Python name of the class (&quot;Calculator&quot;). The second argument is the C++ class that we want to expose (Calculator). We then define the add and subtract member functions using the .def method. Finally, we need to build this module into a shared library so that we can load it into Python. We can do this using CMake: 1234567cmake_minimum_required(VERSION 3.0)project(calculator)find_package(pybind11 REQUIRED)pybind11_add_module(calculator calculator.cpp) This will build a shared library called calculator.so (on Linux) or calculator.pyd (on Windows). We can now load this module into Python and use it like any other Python module: 12345import calculatorc = calculator.Calculator()print(c.add(1, 2)) # Output: 3print(c.subtract(2, 1)) # Output: 1 Conclusion In this article, we have learned how to use Pybind11 to create Python bindings for C++ classes and functions. Pybind11 simplifies the process of creating Python bindings and allows seamless interoperability between C++ and Python. By following the example code provided in this article, you should be able to start creating your own Python bindings for your C++ code.","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"cpp","slug":"cpp","permalink":"https://ben-xj.github.io/tags/cpp/"},{"name":"pybind11","slug":"pybind11","permalink":"https://ben-xj.github.io/tags/pybind11/"}]},{"title":"pulp不同求解器设置参数","slug":"pulp不同求解器设置参数","date":"2023-04-26T12:23:27.000Z","updated":"2023-04-28T14:55:12.000Z","comments":true,"path":"2023/04/26/pulp不同求解器设置参数/","link":"","permalink":"https://ben-xj.github.io/2023/04/26/pulp%E4%B8%8D%E5%90%8C%E6%B1%82%E8%A7%A3%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0/","excerpt":"Pulp provides an easy-to-use syntax and interface for formulating and solving LP problems, including support for a wide range of problem types and solvers. It is widely used in operations research, supply chain management, logistics, and other industries for making optimization decisions.","text":"Pulp provides an easy-to-use syntax and interface for formulating and solving LP problems, including support for a wide range of problem types and solvers. It is widely used in operations research, supply chain management, logistics, and other industries for making optimization decisions. 1234567891011121314151617181920212223from pulp import *# Use CBC solverprob.solve(PULP_CBC_CMD(msg=True, timeLimit=1, options=[&quot;startalg&quot;, &quot;barrier&quot;]))# Use cplex solverprob.solve( CPLEX_CMD(msg=True, timeLimit=1, # interactive cmd options=[&quot;set emphasis mip 3&quot;, &quot;set barrier algorithm 3&quot;]))# Use gurobi solverprob.solve( GUROBI_CMD(msg=True, timeLimit=1, threads=4, options=[(&quot;Method&quot;, 2), (&quot;MIPGap&quot;, 0.2)]))# Use scip solver, latest version of pulp only# support single thread onlyprob.solve(SCIP_CMD(msg=True, timeLimit=1, options=[&quot;branching/clamp=0.4&quot;]))","categories":[{"name":"优化","slug":"优化","permalink":"https://ben-xj.github.io/categories/%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"pulp","slug":"pulp","permalink":"https://ben-xj.github.io/tags/pulp/"},{"name":"solver","slug":"solver","permalink":"https://ben-xj.github.io/tags/solver/"},{"name":"mip","slug":"mip","permalink":"https://ben-xj.github.io/tags/mip/"}]},{"title":"Accelerate Your NumPy Matrix Operations with Cython","slug":"Accelerate Your NumPy Matrix Operations with Cython","date":"2023-03-31T00:44:10.000Z","updated":"2023-04-28T14:54:50.000Z","comments":true,"path":"2023/03/31/Accelerate Your NumPy Matrix Operations with Cython/","link":"","permalink":"https://ben-xj.github.io/2023/03/31/Accelerate%20Your%20NumPy%20Matrix%20Operations%20with%20Cython/","excerpt":"Introduction Python is widely used for scientific computing, data analysis, and machine learning tasks due to its ease of use and rich ecosystem. NumPy, a popular library for numerical computations in Python, provides a powerful array object and a variety of functions to operate on these arrays. However, performance can sometimes be a bottleneck when working with large datasets or complex operations.","text":"Introduction Python is widely used for scientific computing, data analysis, and machine learning tasks due to its ease of use and rich ecosystem. NumPy, a popular library for numerical computations in Python, provides a powerful array object and a variety of functions to operate on these arrays. However, performance can sometimes be a bottleneck when working with large datasets or complex operations. Cython, a superset of the Python language, allows you to write Python code with optional C-like syntax and static types, which can then be compiled to C and executed as a native extension. This can lead to significant performance improvements compared to pure Python code. In this blog post, we will demonstrate how to use Cython with NumPy to optimize matrix operations, and compare the performance of pure Python and Cython-accelerated implementations. Prerequisites To follow along with the examples in this post, make sure you have both Cython and NumPy installed: pip install cython numpy Example: Element-wise Matrix Multiplication Let’s start by implementing element-wise matrix multiplication using Cython with NumPy. Step 1: Create a Cython file Create a Cython file called matrix_mult_cython.pyx with the following code: 123456789101112131415# matrix_mult_cython.pyximport numpy as npcimport numpy as cnpcpdef cnp.ndarray[double, ndim=2] elementwise_multiply(cnp.ndarray[double, ndim=2] A, cnp.ndarray[double, ndim=2] B): cdef int nrows = A.shape[0] cdef int ncols = A.shape[1] cdef cnp.ndarray[double, ndim=2] result = np.zeros((nrows, ncols), dtype=np.float64) cdef int i, j for i in range(nrows): for j in range(ncols): result[i, j] = A[i, j] * B[i, j] return result Note: In Cython, the cimport statement is used to import C-level declarations from other Cython modules or libraries. It is similar to the regular Python import statement, but it specifically deals with importing C-level functions, types, and other constructs that are not part of the Python runtime. In the provided example, the line cimport numpy as cnp is used to import the Cython definitions for the NumPy library. This allows us to interact with NumPy arrays more efficiently, leading to performance improvements. The cnp alias is used in the same way as np for regular Python NumPy imports, but it refers to the C-level NumPy constructs. Step 2: Compile the Cython module Create a setup.py file to build the Cython module: 123456789101112131415# setup.pyfrom setuptools import setup, Extensionfrom Cython.Build import cythonizeimport numpy as npext_modules = [ Extension(&quot;matrix_mult_cython&quot;, [&quot;matrix_mult_cython.pyx&quot;], include_dirs=[np.get_include()]) # Add the NumPy header files]setup( name=&#x27;Matrix Multiplication Cython Example&#x27;, ext_modules=cythonize(ext_modules), zip_safe=False,) Compile the Cython module by running the following command in your terminal: python setup.py build_ext --inplace Note: The zip_safe parameter is an option indicating whether the package can be safely installed and run from a zip archive without being extracted to the file system. When zip_safe is set to True, it means that the package can be installed and run directly from a zip archive without any issues. However, when set to False, it indicates that the package needs to be extracted to the file system before being executed. In the case of Cython-compiled extensions, it is generally recommended to set zip_safe=False. This is because Cython generates compiled C extensions (shared libraries or DLLs) that need to be accessed by the operating system’s dynamic loader, which often cannot read files from a zip archive. Step 3: Use the Cython module in your Python code Now, you can use the compiled Cython module in your Python code: 12345678910111213# main.pyimport numpy as npfrom matrix_mult_cython import elementwise_multiplydef main(): A = np.random.rand(1000, 1000) B = np.random.rand(1000, 1000) result = elementwise_multiply(A, B) print(result)if __name__ == &quot;__main__&quot;: main() Run your Python code: python main.py Performance Comparison To compare the performance before and after using Cython, we can implement the same element-wise multiplication using pure Python with NumPy and then measure the execution time for both the pure Python and Cython-accelerated implementations. Pure Python Implementation Add a pure Python implementation of element-wise multiplication in main.py: 1234567891011def elementwise_multiply_python(A, B): assert A.shape == B.shape, &quot;Both matrices must have the same shape.&quot; nrows, ncols = A.shape result = np.zeros((nrows, ncols), dtype=np.float64) for i in range(nrows): for j in range(ncols): result[i, j] = A[i, j] * B[i, j] return result Timing the Implementations Add timing code to main.py to measure the execution time of both the pure Python and Cython-accelerated implementations: 1234567891011121314151617181920212223import timedef main(): A = np.random.rand(1000, 1000) B = np.random.rand(1000, 1000) # Time the pure Python implementation start_python = time.time() result_python = elementwise_multiply_python(A, B) end_python = time.time() elapsed_python = end_python - start_python # Time the Cython-accelerated implementation start_cython = time.time() result_cython = elementwise_multiply(A, B) end_cython = time.time() elapsed_cython = end_cython - start_cython print(f&quot;Pure Python: &#123;elapsed_python:.5f&#125; seconds&quot;) print(f&quot;Cython-accelerated: &#123;elapsed_cython:.5f&#125; seconds&quot;)if __name__ == &quot;__main__&quot;: main() Run the Python code: python main.py You should see the execution time of both the pure Python implementation and the Cython-accelerated implementation. Typically, the Cython-accelerated implementation should be significantly faster, as it leverages C-level array access and efficient looping. This is the result on my machine: Conclusion In this blog post, we demonstrated how to use Cython with NumPy to optimize matrix operations, specifically element-wise matrix multiplication. We also compared the performance of pure Python and Cython-accelerated implementations, showing that Cython can provide significant performance improvements. Cython is a powerful tool for optimizing Python code that relies on numerical computations, especially when used in conjunction with libraries like NumPy. By taking advantage of C-level array access and efficient looping, you can achieve substantial speedups in your scientific computing, data analysis, and machine learning tasks.","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"cython","slug":"cython","permalink":"https://ben-xj.github.io/tags/cython/"}]},{"title":"2. 基于Django Rest框架构建API","slug":"基于Django-Rest框架构建API","date":"2022-12-31T09:58:24.000Z","updated":"2023-04-26T14:05:28.000Z","comments":true,"path":"2022/12/31/基于Django-Rest框架构建API/","link":"","permalink":"https://ben-xj.github.io/2022/12/31/%E5%9F%BA%E4%BA%8EDjango-Rest%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BAAPI/","excerpt":"1. 什么是API? 简单看一下百科的解释： API之主要目的是提供应用程序与开发人员以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。提供API所定义的功能的软件称作此API的实现。API是一种接口，故而是一种抽象。 应用程序接口（英语：ApplicationProgrammingInterface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。","text":"1. 什么是API? 简单看一下百科的解释： API之主要目的是提供应用程序与开发人员以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。提供API所定义的功能的软件称作此API的实现。API是一种接口，故而是一种抽象。 应用程序接口（英语：ApplicationProgrammingInterface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。 简单来说，我们写程序是为了帮用户完成某件事，用户不需要知道我们是怎么完成的。对于用户来说，只需发个指令，譬如，“我想导航到萧山”，那么程序能把路线告诉用户即可。API是什么呢，就是接受用户指令，并返回程序结果的一个工具。 2. 安装djangorestframework包 作为网络开发程序员，我们要为用户提供API 并告诉用户如何使用我们的软件。用于开发API的工具有很多，在Django项目中，一般使用djangorestframework包来开发API。 djangorestframework包直接使用pip安装即可 1pip install djangorestframework 3. 建立Django项目 在本文中，我们通过建立一个电影网站，让用户 获取、修改以及增加新的电影信息，以熟悉Django API的构建。 可以参考[[基本Django项目构建]]一文建立起项目，简单列举一下相关命令。 12345django-admin startproject movie_apicd movie_apipython manage.py startapp movie # 这里记得在配置文件中加入moviepython manage.py migratepython manage.py runserver 这样就可以跑起来一个空项目了。 因为本文只关注API的构建，这里只建立一个数据模型，其他的网页浏览视图、模板就不做了。 3.1 建立Model 在movie/models.py中建立电影数据类， 123456789from django.db import models# Create your models here.class Movie(models.Model): name = models.CharField(max_length=200) year = models.IntegerField() def __str__(self): return f&#x27;&#123;self.name&#125; (&#123;self.year&#125;)&#x27; 对数据模型更改后，要进行迁移 12python manage.py makemigrationspython manage.py migrate 使用python manage.py shell进行项目的shell添加一些数据 12345678910111213&gt;&gt;&gt; from movie.models import Movie&gt;&gt;&gt; Movie.objects.create(name=&quot;The Shawshank Redemption&quot;, year=1994)&lt;Movie: The Shawshank Redemption (1994)&gt;&gt;&gt;&gt; Movie.objects.create(name=&quot;The Godfather&quot;, year=1972)&lt;Movie: The Godfather (1972)&gt;&gt;&gt;&gt; Movie.objects.create(name=&quot;The Dark Knight&quot;, year=2008)&lt;Movie: The Dark Knight (2008)&gt;&gt;&gt;&gt; Movie.objects.create(name=&#x27;The Godfather: Part II&#x27;, year=1974)&lt;Movie: The Godfather: Part II (1974)&gt;&gt;&gt;&gt; Movie.objects.create(name=&#x27;12 Angry Men&#x27;, year=1957)&lt;Movie: 12 Angry Men (1957)&gt;&gt;&gt;&gt; Movie.objects.all()&lt;QuerySet [&lt;Movie: The Shawshank Redemption (1994)&gt;, &lt;Movie: The Godfather (1972)&gt;, &lt;Movie: The Dark Knight (2008)&gt;, &lt;Movie: The Godfather: Part II (1974)&gt;, &lt;Movie: 12 Angry Men (1957)&gt;]&gt; 4. 构建API 首先在movie_api/settings.py文件找到INSTALLED_APPS， 注册rest_framework，现在这个列表应该如下， 12345INSTALLED_APPS = [ ... # 其他已有值 &#x27;movie&#x27;, &#x27;rest_framework&#x27;,] 为了避免与网站基本内容混淆，可以项目根目录下建立一个专门的api文件夹，并在其中建立一个空的__init__.py文件，表明这是一个包。 4.1 建立序列化器 我们把变量从内存中变成可存储或传输的过程称之为序列化。——廖雪峰 也就是说，从数据库中把数据读到我们的Model类型的变量中后，还要经过序列化，才能顺利传输到客户端（浏览器），供用户浏览使用。 在api文件夹下建立serializers.py文件，内容如下 1234567from rest_framework import serializersfrom movie.models import Movieclass MovieSerializer(serializers.ModelSerializer): class Meta: model = Movie fields= &#x27;__all__&#x27; 这里建立了一个Movie专用的序列化器，其中序列化的数据包括所有字段。 4.2 建立视图并绑定URL 4.2.1 获取所有电影 在api文件夹下建立views.py文件 1234567891011from rest_framework.decorators import api_viewfrom movie.models import Moviefrom .serializers import MovieSerializerfrom rest_framework.response import Response@api_view([&#x27;GET&#x27;])def get_movies(request): movies = Movie.objects.all() serializer = MovieSerializer(movies, many=True) return Response(serializer.data) 这里通过装饰器来设置请求方法，这里只是获取，用GET即可。 注意在一个普通的网站中，获取了电影列表后，应该传输给前端的模板，以供渲染，但在API中，我们进行序列化，以供传输。 然后绑定url，在api文件夹下建立urls.py文件， 123456from django.urls import pathfrom . import viewsurlpatterns = [ path(&#x27;&#x27;, views.get_movies, name=&#x27;get_movies&#x27;)] 如文章[[基本Django项目构建]]中提到的，还没有被django项目所识别，因此，需要在movie_api/urls.py文件中进行引用，以让项目进行识别。 123456from django.urls import path, includeurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;movies/&#x27;, include(&#x27;api.urls&#x27;)),] 这样，运行项目后，我们就可以通过网址http://127.0.0.1:8000/movies/访问电影列表api了，效果如下： 4.2.2 新增电影 新增电影条目可以保持与电影列表的网址相同，只需要在视图中增加一个POST请求方法即可。修改api/views.py中相关函数如下， 1234567891011121314from rest_framework import status@api_view([&#x27;GET&#x27;, &#x27;POST&#x27;])def get_movies(request): if request.method == &#x27;GET&#x27;: movies = Movie.objects.all() serializer = MovieSerializer(movies, many=True) return Response(serializer.data) elif request.method == &#x27;POST&#x27;: serializer = MovieSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 要注意的是，一旦数据有变动，要使用is_valid进行数据的验证并使用save保存，这里包括类型、长度等的验证。 再次访问网址http://127.0.0.1:8000/movies/，可以看到下方多出了一个输入框，以增加电影条目。 4.2.3 获取某个电影的信息 这里也是获取内容，与[[#4 2 1 获取所有电影]]类似，首先在api/views.py中添加视图函数， 12345@api_view([&#x27;PUT&#x27;])def get_movie_detail(request, id): movie = Movie.objects.get(pk=id) serializer = MovieSerializer(movie) return Response(serializer.data) 然后在api/urls.py中绑定网址， 123urlpatterns = [ path(&#x27;&lt;int:id&gt;&#x27;, views.get_movie_detail, name=&#x27;get_movie_detail&#x27;),] 即可通过http://127.0.0.1:8000/movies/1 访问id为1的电影信息了。 4.2.4 修改或删除某个电影的信息 修改或删除也是针对某个电影，所以网址与[[#4 2 3 获取某个电影的信息]]可以相同，不过请求方法需要设置为PUT和DELETE，修改相应的视图函数如下： 123456789101112131415@api_view([&#x27;GET&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;])def get_movie_detail(request, id): movie = Movie.objects.get(pk=id) if request.method == &#x27;GET&#x27;: serializer = MovieSerializer(movie) return Response(serializer.data) elif request.method == &#x27;PUT&#x27;: serializer = MovieSerializer(movie, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == &#x27;DELETE&#x27;: movie.delete() return Response(status=status.HTTP_204_NO_CONTENT) 这里增加了对请求方法PUT和DELETE的支持，在函数体中，针对不同的请求类型，有不同的处理。 修改后页面效果如下，可以进行内容的修改和条目的删除。 5. 回顾 简单回顾一下，在一个普通的网站项目基础上，首先建立了专门的API文件夹，在其中首先建立序列化器以进行数据转化传输，然后建立了各类视图，并通过不同请求方法进行数据的增、删、改、查（即CRUD操作）API的构建。 可以看到，API的视图函数与一般网站视图函数的主要区别在于，API的视图函数是从数据库获取数据后进行序列化再传输，而一般网站视图函数则是获取数据后传递给前端模板以供展示。","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://ben-xj.github.io/tags/django/"},{"name":"后端框架","slug":"后端框架","permalink":"https://ben-xj.github.io/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"api","slug":"api","permalink":"https://ben-xj.github.io/tags/api/"}]},{"title":"1. 基本Django项目构建","slug":"基本Django项目构建","date":"2022-12-31T09:53:37.000Z","updated":"2023-04-29T11:38:24.000Z","comments":true,"path":"2022/12/31/基本Django项目构建/","link":"","permalink":"https://ben-xj.github.io/2022/12/31/%E5%9F%BA%E6%9C%ACDjango%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/","excerpt":"1. 创建django项目 可通过如下命令创建名为myproject的django项目，","text":"1. 创建django项目 可通过如下命令创建名为myproject的django项目， 123django-admin startproject myprojectcd myprojectpython manage.py migrate 备注 python manage.py migrate意思是把数据模型（Python中定义的Model）和数据库同步。 python manage.py makemigrations是当模型的相关代码发生变动时，对变动进行提交保存，后接migrate 2. 创建app 1python manage.py startapp base # 这里base就是app的名字 创建完成后要注册app，在setting.py中找到INSTALLED_APPS，加入app名 1234INSTALLED_APPS = [ &#x27;base&#x27;, ...] 一个django项目的结构如下 3. 创建数据模型（Model） 在models.py中，建立数据模型，类似于pojo，即一个对象包含哪些字段，这也被称为Schema。 123456from django.db import models# Create your models here.class Item(models.Model): name = models.CharField(max_length=200) created = models.DateTimeField(auto_now_add=True) 如上所述，数据模型变动后，要进行迁移 12python manage.py makemigrationspython manage.py migrate makemigrations后，即建立了数据模型和数据库的联系，可以通过python manage.py sqlmigrate base 0001生成sql语句，但这只是供查看确认，并不执行，migrate才是执行。 临时加入数据 可以另外开一个shell进行一些操作，比如添加数据 1python manage.py shell 这条命令相比直接运行python，可以导入该django项目的环境变量。 在shell中添加数据 12345678910111213&gt;&gt;&gt; from base.models import Item&gt;&gt;&gt; Item.objects.create(name=&#x27;item1&#x27;)&lt;Item: Item object (1)&gt;&gt;&gt;&gt; Item.objects.create(name=&#x27;item2&#x27;)&lt;Item: Item object (2)&gt;&gt;&gt;&gt; Item.objects.create(name=&#x27;item3&#x27;)&lt;Item: Item object (3)&gt;&gt;&gt;&gt; items = Item.objects.all()&gt;&gt;&gt; print(items)&lt;QuerySet [&lt;Item: Item object (1)&gt;, &lt;Item: Item object (2)&gt;, &lt;Item: Item object (3)&gt;]&gt;# 也可以这样&gt;&gt;&gt; item = Item(name=&#x27;item4&#x27;)&gt;&gt;&gt; item.save() 4. 创建后端逻辑（View） 在views.py文件中完成 比如最简单的， 12def home(request): return HttpResponse(&quot;home page&quot;) 这样后续执行该逻辑时，网页上就显示了home page这行字。 当然，更一般的，后端会提供一些数据处理，并显示在定义好的前端模板上，这样就要和前端模板绑定。比如现在要把所有的物品显示在前端页面上，那么后端就要从数据库拉取所有的items， 123def get_items(request): items = Item.objects.all() return render(request, &#x27;items.html&#x27;, &#123;&#x27;items&#x27;: items&#125;) 这样就可以把items数据传递给items.html这个前端模板。 5. 创建前端模板（templates） 在base文件夹下创建templates文件夹，再在templates文件夹下创建base文件夹，并在其中新建items.html文件，即base/templates/base/items.html，这样设置后，在django项目中，我们可以通过base/items.html定位到这个模板。 Django框架中存在模板寻找器，可搜索每个app的特定文件夹。 文件内容如下 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Items&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &#123;% for item in items %&#125; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 大意就是把各个物品的名字显示成一个无序列表。 6. 绑定网址 以上已经完成了后端与数据库、前端与后端的数据传递，那么用户如何访问这样一个网页呢？就需要在urls.py中绑定好网址和后端。 在base文件夹下新建urls.py文件，内容如下 1234567from . import views from django.urls import pathurlpatterns = [ path(&quot;items/&quot;, views.get_items), path(&quot;&quot;, views.home)] 但这个url目前只在base这个app下，并没有被django项目所识别，因此，需要在myproject/urls.py文件中进行引用，以让项目进行识别。 123456from django.urls import include # 这是新增的行urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;base/&#x27;, include(&#x27;base.urls&#x27;)) # 这是新增的行] 7. 运行 最后，执行python manage.py runserver即可运行网站，打开http://127.0.0.1:8000/base/items/ 就显示了物品列表如下。 8. 参考 Django Crash Course - Introduction + Python Web Development Tutorial Django REST Framework Oversimplified","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://ben-xj.github.io/tags/django/"},{"name":"后端框架","slug":"后端框架","permalink":"https://ben-xj.github.io/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"api","slug":"api","permalink":"https://ben-xj.github.io/tags/api/"}]},{"title":"tmux够用命令","slug":"tmux够用命令","date":"2022-12-31T00:44:10.000Z","updated":"2023-05-16T12:33:36.000Z","comments":true,"path":"2022/12/31/tmux够用命令/","link":"","permalink":"https://ben-xj.github.io/2022/12/31/tmux%E5%A4%9F%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Tmux is a terminal multiplexer for Unix-like systems. It allows users to create and manage multiple terminal sessions within a single terminal window or console. Tmux provides many features that are useful for working in a command-line environment. For example, it allows users to detach and reattach sessions, which means that users can start a session, disconnect from it and then reconnect to it later. This feature is particularly useful for long-running tasks that continue even after the user has logged out or disconnected from the network.","text":"Tmux is a terminal multiplexer for Unix-like systems. It allows users to create and manage multiple terminal sessions within a single terminal window or console. Tmux provides many features that are useful for working in a command-line environment. For example, it allows users to detach and reattach sessions, which means that users can start a session, disconnect from it and then reconnect to it later. This feature is particularly useful for long-running tasks that continue even after the user has logged out or disconnected from the network. 1. Session 会话 可以理解为一个连接，tmux其实是提供了一个终端服务，这个服务可以允许我们创建多个终端会话。 1.1 创建匿名和命名的会话 12tmux newtmux new -s &lt;session-name&gt; 创建后会自动进入该会话的窗口（下一节详细说明窗口）。 1.2 离开会话 1ctrl+b d 即离开当前的会话，回到系统的终端窗口。tmux会话的一大优点是不会随着终端gui的关闭而停止，会话仍保持后台运行，后续可通过attach命令重新进入。 1.3 查看会话列表及进入会话 我们可以同时运行多个会话，互不干扰，查看会话列表的命令为 1tmux ls 第一列就是会话的名字，进入指定会话命令为 1tmux attach -t &lt;session-name&gt; 这里-t表示target。 1.4 退出会话（删除） 1234# 会话内exit# 会话外/内tmux kill-session -t &lt;session-name&gt; 这是彻底退出会话，不会保留后台。 1.5 重命名会话 1tmux rename-session -t &lt;session-name&gt; &lt;new-name&gt; 2. Window 窗口 每次进入会话看到的都是一个会话窗口，而实际上tmux允许我们在一个session开启多个窗口，窗口可以简单理解为一个个tab页。 2.1 新窗口 1ctrl+b c 这个动作开启了一个新窗口，并自动进入新窗口。可以通过下方状态栏观察。 2.2 窗口跳转 那如果我想跳回去之前的窗口，可以通过命令 1ctrl+b &lt;window-name&gt; 2.3 窗口重命名 这时候我们发现，这些窗口名都是数字，开多了自己都不知道往哪找想要的窗口了，那么，可以把窗口改个容易识别的名字，这样就知道每个窗口在做什么啦。 1ctrl+b , 2.4 关闭窗口 最后，当不再使用某个窗口，可以关掉 1ctrl+d或exit 3. Pane 面板 最后的最后，如果你的屏幕足够大，一个窗口只能同时跑一个命令不是很浪费？tmux提供了多面板支持，可以把当前窗口一分为2、3、4… 3.1 水平划分 1ctrl+b % 效果如下 3.2 垂直划分 1ctrl+b &quot; 效果如下 当然，水平和垂直划分可以随意组合 3.3 pane间切换 这么多面板，怎么跳到指定的那一个，当然不是用鼠标点，我们还是用ctrl+b命令，结合上下左右方向键就可以切换了。 3.4 关闭pane 如果觉得太凌乱，就关掉几个pane吧，命令和关窗口一样。 以上。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ben-xj.github.io/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://ben-xj.github.io/tags/shell/"},{"name":"tmux","slug":"tmux","permalink":"https://ben-xj.github.io/tags/tmux/"}]},{"title":"5. 半正定锥","slug":"半正定锥","date":"2022-04-17T12:19:23.000Z","updated":"2023-04-29T12:37:32.000Z","comments":true,"path":"2022/04/17/半正定锥/","link":"","permalink":"https://ben-xj.github.io/2022/04/17/%E5%8D%8A%E6%AD%A3%E5%AE%9A%E9%94%A5/","excerpt":"1. 几个符号 1.1 对称方阵的集合","text":"1. 几个符号 1.1 对称方阵的集合 Sn={X∈Rn×n∣X=XT}\\mathbf{S}^{n}= \\{ X \\in \\mathbf{R}^{n \\times n} \\mid X=X^{T} \\} Sn={X∈Rn×n∣X=XT} S for symmetric 1.2 对称半正定方阵的集合 S+n={X∈Sn∣X⪰0}\\mathbf{S}^{n}_{+}= \\{X \\in \\mathbf{S}^{n} \\mid X \\succeq 0 \\} S+n​={X∈Sn∣X⪰0} ⪰\\succeq⪰表示矩阵的特征值≥0\\ge 0≥0 1.3 对称正定方阵的集合 S++n={X∈Sn∣X≻0}\\mathbf{S}^{n}_{++}= \\{X \\in \\mathbf{S}^{n} \\mid X \\succ 0 \\} S++n​={X∈Sn∣X≻0} 1.4 证明对称半正定方阵为凸锥 半正定矩阵有： xTAx≥0x^TAx \\ge 0 xTAx≥0 代入凸锥的定义即可证 xT(θ1A+θ2B)x=θ1xTAx+θ2xTBx≥0x^{T}\\left(\\theta_{1} A+\\theta_{2} B\\right) x=\\theta_{1} x^{T} A x+\\theta_{2} x^{T} B x \\geq 0 xT(θ1​A+θ2​B)x=θ1​xTAx+θ2​xTBx≥0 1.5 对比 Sn\\mathbf{S}^{n}Sn、S+n\\mathbf{S}^{n}_+S+n​是凸锥（当然也是凸集）； S++n\\mathbf{S}^{n}_{++}S++n​是凸集，不是凸锥，因为不包含0点。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"https://ben-xj.github.io/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"https://ben-xj.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"4. 多面体和单纯形","slug":"多面体和单纯形","date":"2022-04-17T12:16:41.000Z","updated":"2023-04-29T12:43:28.000Z","comments":true,"path":"2022/04/17/多面体和单纯形/","link":"","permalink":"https://ben-xj.github.io/2022/04/17/%E5%A4%9A%E9%9D%A2%E4%BD%93%E5%92%8C%E5%8D%95%E7%BA%AF%E5%BD%A2/","excerpt":"1. 多面体(Polyhedron) 多面体是一系列线性等式和不等式的解集。","text":"1. 多面体(Polyhedron) 多面体是一系列线性等式和不等式的解集。 P={x∣ajTx≤bj,j=1,…,m,cjTx=dj,j=1,…,p}\\mathcal{P}=\\{x \\mid a_{j}^{T} x \\leq b_{j}, j=1, \\ldots, m, c_{j}^{T} x=d_{j}, j=1, \\ldots, p\\} P={x∣ajT​x≤bj​,j=1,…,m,cjT​x=dj​,j=1,…,p} 向量形式为 P={x∣Ax⪯b,Cx=d}\\mathcal{P}= \\{x \\mid A x \\preceq b, C x=d \\}P={x∣Ax⪯b,Cx=d} 从定义可以看出，多面体就是超平面和半空间的交集。 有界的多面体称为Polytope。 2. 单纯形(Simplex) 2.1 定义 假设k+1k+1k+1个点v0,…,vk∈Rnv_0, \\ldots, v_k \\in R^nv0​,…,vk​∈Rn仿射独立，即v1−v0,…,vk−v0v_1-v_0, \\ldots, v_k-v_0v1​−v0​,…,vk​−v0​线性不相关，则与这k+1k+1k+1个点相关的单纯形 即为这些点的凸包： C=conv⁡{v0,…,vk}={θ0v0+⋯+θkvk∣θ⪰0,1Tθ=1}\\begin{align} C &amp; = \\operatorname{conv}\\{v_{0}, \\ldots, v_{k}\\} \\\\ &amp; = \\{\\theta_{0} v_{0}+\\cdots+\\theta_{k} v_{k} \\mid \\theta \\succeq 0, \\mathbf{1}^{T} \\theta = 1\\} \\end{align} C​=conv{v0​,…,vk​}={θ0​v0​+⋯+θk​vk​∣θ⪰0,1Tθ=1}​​ 2.2 例子 以二维空间为例 若给两个不同的点，则构成的单纯形为一条线段 若给三个不同的点，则构成的单纯形为一个三角形 若给四个以上不同的点，则不可能仿射独立，不能构成单纯形 2.3 证明单纯形是多面体 思路： 把单纯形中的点表示成多面体的形式 线性不相关-&gt;满秩 设单纯形为CCC，则CCC中的点可表示为 x=θ0v0+θ1v1+⋯+θkvkx=\\theta_{0} v_{0}+\\theta_{1} v_{1}+\\cdots+\\theta_{k} v_{k} x=θ0​v0​+θ1​v1​+⋯+θk​vk​ 其中θ⪰0,1Tθ=1\\theta \\succeq 0, \\mathbf{1}^{T} \\theta = 1θ⪰0,1Tθ=1，要注意的是θ\\thetaθ是可变的，决定了xxx的取值。 对上式进行变换，得 x=v0+θ1(v1−v0)+⋯+θk(vk−v0)=v0+By\\begin{align} x &amp;= v_{0}+\\theta_{1} (v_{1}-v_{0})+\\cdots+\\theta_{k} (v_{k}-v_{0})\\\\ &amp;=v_0 +By \\end{align} x​=v0​+θ1​(v1​−v0​)+⋯+θk​(vk​−v0​)=v0​+By​​ 其中 B=[v1−v0⋯vk−v0]∈Rn×ky=(θ1,…,θk)\\begin{align} B &amp; = \\left[\\begin{array}{lll} v_{1}-v_{0} &amp; \\cdots &amp; v_{k}-v_{0} \\end{array}\\right] \\in \\mathbf{R}^{n \\times k}\\\\ y &amp; = \\left(\\theta_{1}, \\ldots, \\theta_{k}\\right) \\end{align}By​=[v1​−v0​​⋯​vk​−v0​​]∈Rn×k=(θ1​,…,θk​)​​ 注意这里的yyy不是θ\\thetaθ，少了一个元素。y⪰0,1Ty≤1y \\succeq 0,\\mathbf{1}^{T} y \\le 1y⪰0,1Ty≤1。显然可以用yyy的约束条件来得到对xxx的约束，那么下一步要做的就是把yyy独立出来。 由于BBB中各向量线性无关，则rank(B)=krank(B)=krank(B)=k，因此，存在非奇异矩阵A=(A1,A2)∈Rn×nA=(A_1, A_2) \\in R^{n \\times n}A=(A1​,A2​)∈Rn×n使得， AB=[A1A2]B=[I0]A B=\\left[\\begin{array}{l} A_{1} \\\\ A_{2} \\end{array}\\right] B=\\left[\\begin{array}{l} I \\\\ 0 \\end{array}\\right] AB=[A1​A2​​]B=[I0​] 在xxx的表达式左边乘上矩阵AAA，可得 A1x=A1v0+y,A2x=A2v0A_{1} x=A_{1} v_{0}+y, \\quad A_{2} x=A_{2} v_{0}A1​x=A1​v0​+y,A2​x=A2​v0​ 代入yyy的约束，可得 A2x=A2v0,A1x⪰A1v0,1TA1x≤1+1TA1v0A_{2} x=A_{2} v_{0}, \\quad A_{1} x \\succeq A_{1} v_{0}, \\quad \\mathbf{1}^{T} A_{1} x \\leq 1+\\mathbf{1}^{T} A_{1} v_{0} A2​x=A2​v0​,A1​x⪰A1​v0​,1TA1​x≤1+1TA1​v0​ 符合多面体的定义，证毕。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"https://ben-xj.github.io/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"https://ben-xj.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"3. 球和椭球","slug":"球和椭球","date":"2022-04-17T05:49:31.000Z","updated":"2023-04-29T12:43:54.000Z","comments":true,"path":"2022/04/17/球和椭球/","link":"","permalink":"https://ben-xj.github.io/2022/04/17/%E7%90%83%E5%92%8C%E6%A4%AD%E7%90%83/","excerpt":"1. 球(Ball) 1.1 定义 球有两种形式的定义","text":"1. 球(Ball) 1.1 定义 球有两种形式的定义 1.1.1 定义一 B(xc,r)={x∣∥x−xc∥2≤r}={x∣(x−xc)T(x−xc)≤r2}\\begin{align} B\\left(x_{c}, r\\right) &amp; = \\{x \\mid\\left\\|x-x_{c}\\right\\|_{2} \\leq r\\}\\\\&amp; = \\{x \\mid\\left(x-x_{c}\\right)^{T}\\left(x-x_{c}\\right) \\leq r^{2}\\} \\end{align} B(xc​,r)​={x∣∥x−xc​∥2​≤r}={x∣(x−xc​)T(x−xc​)≤r2}​​ 其中xcx_cxc​为球心，rrr为半径。 1.1.2 定义二 B(xc,r)={xc+ru∣∥u∥2≤1}B\\left(x_{c}, r\\right)=\\{x_{c}+r u \\mid\\|u\\|_{2} \\leq 1\\} B(xc​,r)={xc​+ru∣∥u∥2​≤1} 从直观上看，我们都知道球一定是个凸集。下面分别通过两种定义进行证明： 1.2 球为凸集的证明 1.2.1 利用定义一证明 ∥θx1+(1−θ)x2−xc∥2=∥θ(x1−xc)+(1−θ)(x2−xc)∥2≤θ∥x1−xc∥2+(1−θ)∥x2−xc∥2≤r.\\begin{aligned} \\|\\theta x_{1}+(1-\\theta) x_{2}-x_{c}\\|_{2} &amp;=\\|\\theta (x_{1}-x_{c} )+(1-\\theta) (x_{2}-x_{c} ) \\|_{2} \\\\ &amp; \\leq \\theta \\|x_{1}-x_{c} \\|_{2}+(1-\\theta) \\|x_{2}-x_{c} \\|_{2} \\\\ &amp; \\leq r . \\end{aligned} ∥θx1​+(1−θ)x2​−xc​∥2​​=∥θ(x1​−xc​)+(1−θ)(x2​−xc​)∥2​≤θ∥x1​−xc​∥2​+(1−θ)∥x2​−xc​∥2​≤r.​ 这里关键就是用到了三角不等式 1.2.2 利用定义二证明 θ(xc+ru1)+(1−θ)(xc+ru2)=xc+r(θu1+(1−θ)u2)\\theta(x_c+ru_1)+(1-\\theta)(x_c+ru_2)=x_c+r\\left(\\theta u_1+(1-\\theta)u_2\\right) θ(xc​+ru1​)+(1−θ)(xc​+ru2​)=xc​+r(θu1​+(1−θ)u2​) 那么只需要保证 ∥θu1+(1−θ)u2∥2≤1\\|\\theta u_1+(1-\\theta)u_2\\|_{2} \\le 1 ∥θu1​+(1−θ)u2​∥2​≤1 同样用三角不等式容易证明。 2. 椭球(Ellipsoid) 2.1 定义 同样，也有两种定义形式 2.1.1 定义一 E={x∣(x−xc)TP−1(x−xc)≤1}\\mathcal{E}=\\{x \\mid\\left(x-x_{c}\\right)^{T} P^{-1}\\left(x-x_{c}\\right) \\leq 1\\} E={x∣(x−xc​)TP−1(x−xc​)≤1} 其中P=PT≻0P=P^{T} \\succ 0P=PT≻0，即对称且正定。椭球的半轴就是矩阵PPP的特征值的方根。 特别地，当P=r2IP=r^2 IP=r2I，该点集为一个半径为rrr的球。 2.1.2 定义二 E={xc+Au∣∥u∥2≤1}\\mathcal{E}=\\{x_{c}+A u \\mid\\|u\\|_{2} \\leq 1\\} E={xc​+Au∣∥u∥2​≤1} 这里A=P1/2A=P^{1/2}A=P1/2。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"https://ben-xj.github.io/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"https://ben-xj.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"2. 超平面和半空间","slug":"超平面和半空间","date":"2022-04-17T05:47:34.000Z","updated":"2023-04-26T14:06:30.000Z","comments":true,"path":"2022/04/17/超平面和半空间/","link":"","permalink":"https://ben-xj.github.io/2022/04/17/%E8%B6%85%E5%B9%B3%E9%9D%A2%E5%92%8C%E5%8D%8A%E7%A9%BA%E9%97%B4/","excerpt":"1. 超平面(hyperplane) 形如{x∣aTx=b}(a≠0)\\{x \\mid a^Tx=b \\}(a \\ne 0){x∣aTx=b}(a=0)的就是超平面","text":"1. 超平面(hyperplane) 形如{x∣aTx=b}(a≠0)\\{x \\mid a^Tx=b \\}(a \\ne 0){x∣aTx=b}(a=0)的就是超平面 可以看成是一系列点的集合，这些点与向量aaa的内积为一个固定的常数。而bbb则是该超平面相对于原点的偏移量，原定义可以写作 {x∣aT(x−x0)=0}\\{ x \\mid a^T(x-x_0)=0 \\} {x∣aT(x−x0​)=0} 其中x0x_0x0​为超平面上一点。 2. 半空间(halfspace) 超平面可以把RnR^nRn分割为两个半空间，形如{x∣aTx≤b}(a≠0)\\{x \\mid a^Tx \\le b \\}(a \\ne 0){x∣aTx≤b}(a=0)的就是半空间 用定义可证，半空间也是一个凸集（[[1. 仿射集-凸集-凸锥#凸集 convex set]]） 3. 子空间(subspace) 要区分子空间和半空间。 所谓子空间，或者空间，即存在以下性质的点集合：对于x1,x2∈Vx_1, x_2 \\in Vx1​,x2​∈V，有 αx1+βx2∈V,α,β∈R\\alpha x_1 + \\beta x_2 \\in V, \\quad \\alpha,\\beta \\in R αx1​+βx2​∈V,α,β∈R","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"https://ben-xj.github.io/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"https://ben-xj.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]},{"title":"批量爬取大学课件","slug":"批量爬取大学课件","date":"2022-04-16T01:36:22.000Z","updated":"2023-04-26T14:06:14.000Z","comments":true,"path":"2022/04/16/批量爬取大学课件/","link":"","permalink":"https://ben-xj.github.io/2022/04/16/%E6%89%B9%E9%87%8F%E7%88%AC%E5%8F%96%E5%A4%A7%E5%AD%A6%E8%AF%BE%E4%BB%B6/","excerpt":"国外很多大学的课件放在一个专门的页面上，如下图所示，那么很容易通过一个爬虫批量下载下来。 思路就是识别页面中以pdf结尾的链接，然后进行下载。","text":"国外很多大学的课件放在一个专门的页面上，如下图所示，那么很容易通过一个爬虫批量下载下来。 思路就是识别页面中以pdf结尾的链接，然后进行下载。 单线程版本 123456789101112131415import requestsfrom bs4 import BeautifulSoupurl = &#x27;https://inst.eecs.berkeley.edu/~ee127/fa19/Lectures/&#x27;page = requests.get(url).contentsoup = BeautifulSoup(page, &#x27;html.parser&#x27;)links = soup.find_all(&#x27;a&#x27;)for link in links: href = link.get(&#x27;href&#x27;) if href.endswith(&#x27;.pdf&#x27;): file_url = url + href with open(href, &#x27;wb&#x27;) as f: f.write(requests.get(file_url).content) 下载25个文件，费时180秒左右。 多线程版本 对于这种国外网站，常常下载速度较慢，这种IO密集型的任务使用多线程就非常有必要了。 123456789101112131415161718192021222324from threading import Threadimport requestsfrom bs4 import BeautifulSoupdef download(url, href): r = requests.get(url + href) with open(href, &#x27;wb&#x27;) as f: f.write(r.content)url = &#x27;https://inst.eecs.berkeley.edu/~ee127/fa19/Lectures/&#x27;page = requests.get(url).contentsoup = BeautifulSoup(page, &#x27;html.parser&#x27;)links = soup.find_all(&#x27;a&#x27;)threads = []for link in links: href = link.get(&#x27;href&#x27;) if href.endswith(&#x27;.pdf&#x27;): t = Thread(target=download, args=(url, href)) threads.append(t) t.start()for t in threads: t.join() 这时，下载同样的文件，只需12秒左右，效果还是很明显的。","categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://ben-xj.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"1. 仿射集、凸集、凸锥","slug":"仿射集 凸集 凸锥","date":"2022-04-16T00:44:10.000Z","updated":"2023-04-26T14:05:06.000Z","comments":true,"path":"2022/04/16/仿射集 凸集 凸锥/","link":"","permalink":"https://ben-xj.github.io/2022/04/16/%E4%BB%BF%E5%B0%84%E9%9B%86%20%E5%87%B8%E9%9B%86%20%E5%87%B8%E9%94%A5/","excerpt":"1. 仿射集(affine set) 1.1 直线(line)","text":"1. 仿射集(affine set) 1.1 直线(line) 通过两个点x1≠x2x_1 \\ne x_2x1​=x2​，可构造一条直线 y=θx1+(1−θ)x2y=\\theta x_1 + (1-\\theta) x_2 y=θx1​+(1−θ)x2​ 其中θ∈R\\theta \\in Rθ∈R。若令θ∈[0,1]\\theta \\in [0,1]θ∈[0,1]，则为一条线段。 这个式子可以简单变换为 y=x2+θ(x1−x2)y=x_2 + \\theta(x_1 - x_2) y=x2​+θ(x1​−x2​) 表示以x2x_2x2​为基准点，向x1−x2x_1-x_2x1​−x2​方向构造的一系列新的点。 把θ\\thetaθ看作变量，上式其实就是对θ\\thetaθ的线性变换加上一个常数，这就是仿射.（仿射变换，又称仿射映射，是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。） 1.2 仿射组合(affine combination) 给定若干点xi(i=1,…,k)x_i(i=1,\\ldots,k)xi​(i=1,…,k)，定义 y=θ1x1+θ2x2+⋯+θkxky=\\theta_1 x_1 + \\theta_2 x_2 + \\cdots + \\theta_k x_k y=θ1​x1​+θ2​x2​+⋯+θk​xk​ 为这些点的仿射组合。其中θi∈R\\theta_i \\in Rθi​∈R 且θ1+θ2+⋯+θk=1\\theta_1 + \\theta_2 + \\cdots + \\theta_k=1θ1​+θ2​+⋯+θk​=1。 1.3 仿射集(affine set) 一个集合CCC被称为仿射集，其充分条件是“经过其中任意两点的直线仍在此集合中”。即对任意x1,x2∈Cx_1, x_2 \\in Cx1​,x2​∈C， y=θx1+(1−θ)x2y=\\theta x_1 + (1-\\theta) x_2 y=θx1​+(1−θ)x2​ 也在集合CCC中，其中θ∈R\\theta \\in Rθ∈R，则CCC为仿射集。 设x0∈Cx_0 \\in Cx0​∈C，则 V=C−x0={x−x0∣x∈C}V=C-x_0=\\left\\{x-x_0 | x \\in C\\right\\} V=C−x0​={x−x0​∣x∈C} 是一个与C相关的[[子空间(subspace)]] 例子1 线性方程组{x∣Ax=b}\\{x \\mid A x=b\\}{x∣Ax=b}的解集CCC一定是仿射集。反之，每个仿射集都可以表示为一个线性方程组的解集。 根据定义，CCC对应的子空间为{x∣Ax=0}\\{x \\mid A x=0\\}{x∣Ax=0}，即AAA的化零空间(nullspace)。 1.4 仿射包(affine hull) 任意集合CCC，构造尽可能小的仿射集。 即集合CCC中所有点的仿射组合称为关于CCC的仿射包（ aff C\\text { aff } C aff C，包是指包含、包裹之意）。 aff C={θ1x1+⋯+θkxk∣x1,…,xk∈C,θ1+⋯+θk=1}\\text { aff } C=\\left\\{\\theta_{1} x_{1}+\\cdots+\\theta_{k} x_{k} \\mid x_{1}, \\ldots, x_{k} \\in C, \\theta_{1}+\\cdots+\\theta_{k}=1\\right\\} aff C={θ1​x1​+⋯+θk​xk​∣x1​,…,xk​∈C,θ1​+⋯+θk​=1} 2. 凸集(convex set) 2.1 凸组合(convex combination) 给定若干点xi(i=1,…,k)x_i(i=1,\\ldots,k)xi​(i=1,…,k)，定义 y=θ1x1+θ2x2+⋯+θkxky=\\theta_1 x_1 + \\theta_2 x_2 + \\cdots + \\theta_k x_k y=θ1​x1​+θ2​x2​+⋯+θk​xk​ 其中θi≥0\\theta_i \\ge 0θi​≥0 且θ1+θ2+⋯+θk=1\\theta_1 + \\theta_2 + \\cdots + \\theta_k=1θ1​+θ2​+⋯+θk​=1，yyy称作x1,x2,…,xkx_1, x_2, \\ldots, x_kx1​,x2​,…,xk​的一个凸组合。 2.2 凸集(convex set) 一个集合CCC被称为凸集，其充分条件是“经过其中任意两点的线段仍在此集合中”。即对任意x1,x2∈Cx_1, x_2 \\in Cx1​,x2​∈C， y=θx1+(1−θ)x2y=\\theta x_1 + (1-\\theta) x_2 y=θx1​+(1−θ)x2​ 也在集合CCC中，其中θ∈[0,1]\\theta \\in [0,1]θ∈[0,1]，则CCC为凸集。可见，凸集的要求比仿射集低，任何仿射集都是凸集。 2.3 凸包(convex hull) 对任意集合CCC，集合CCC中所有点的凸组合称为凸包，可记作conv⁡C\\operatorname{conv} CconvC。 conv⁡C={θ1x1+⋯+θkxk∣xi∈C,θi≥0,i=1,…,k,θ1+⋯+θk=1}\\operatorname{conv} C=\\left\\{\\theta_{1} x_{1}+\\cdots+\\theta_{k} x_{k} \\mid x_{i} \\in C, \\theta_{i} \\geq 0, i=1, \\ldots, k, \\theta_{1}+\\cdots+\\theta_{k}=1\\right\\} convC={θ1​x1​+⋯+θk​xk​∣xi​∈C,θi​≥0,i=1,…,k,θ1​+⋯+θk​=1} 3. 凸锥(convex cone) 3.1 锥(cone) 对于集合CCC中任意点xxx和任意常数θ≥0\\theta \\ge 0θ≥0，都有θx∈C\\theta x \\in Cθx∈C，则CCC称为锥。 注： 一条任意射线不一定是锥 一条端点在0点的射线是锥 两条端点在0点的射线是锥 3.2 锥组合(conic combination) 简单理解，conic 就是非负（或者单边）的意思。 给定若干点xi(i=1,…,k)x_i(i=1,\\ldots,k)xi​(i=1,…,k)，定义 y=θ1x1+θ2x2+⋯+θkxky=\\theta_1 x_1 + \\theta_2 x_2 + \\cdots + \\theta_k x_k y=θ1​x1​+θ2​x2​+⋯+θk​xk​ 其中θi≥0\\theta_i \\ge 0θi​≥0 ，yyy称作x1,x2,…,xkx_1, x_2, \\ldots, x_kx1​,x2​,…,xk​的一个锥组合。 3.3 凸锥(convex cone) 若从凸锥组合仍属于原集合，则称为凸锥。 即对任意x1,x2∈Cx_1, x_2 \\in Cx1​,x2​∈C， y=θ1x1+θ2x2y=\\theta_1 x_1 + \\theta_2 x_2 y=θ1​x1​+θ2​x2​ 也在集合CCC中，其中θi≥0\\theta_i \\ge 0θi​≥0，则CCC为凸锥。显然，凸锥的要求包含对凸集的要求，任何凸锥都是凸集。 注： 两条端点在0点的射线不是凸锥 两条端点在0点的射线及其构成的扇形区域是凸锥 3.4 锥包(conic hull) 对任意集合CCC，集合CCC中所有点的锥组合称为锥包。 {θ1x1+⋯+θkxk∣xi∈C,θi≥0,i=1,…,k}\\left\\{\\theta_{1} x_{1}+\\cdots+\\theta_{k} x_{k} \\mid x_{i} \\in C, \\theta_{i} \\geq 0, i=1, \\ldots, k\\right\\} {θ1​x1​+⋯+θk​xk​∣xi​∈C,θi​≥0,i=1,…,k} 4. 特殊集合对比 4.1 点 一个点一定是仿射集和凸集，但不一定是锥，只有原点可以单独构成一个凸锥。 4.2 空集 空集既是仿射集，又是凸集和凸锥。","categories":[{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"https://ben-xj.github.io/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"凸优化","slug":"凸优化","permalink":"https://ben-xj.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://ben-xj.github.io/categories/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://ben-xj.github.io/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"https://ben-xj.github.io/categories/Java/"},{"name":"优化","slug":"优化","permalink":"https://ben-xj.github.io/categories/%E4%BC%98%E5%8C%96/"},{"name":"中科大凸优化课程笔记","slug":"中科大凸优化课程笔记","permalink":"https://ben-xj.github.io/categories/%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%B8%E4%BC%98%E5%8C%96%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ben-xj.github.io/tags/python/"},{"name":"generator","slug":"generator","permalink":"https://ben-xj.github.io/tags/generator/"},{"name":"linux","slug":"linux","permalink":"https://ben-xj.github.io/tags/linux/"},{"name":"grep","slug":"grep","permalink":"https://ben-xj.github.io/tags/grep/"},{"name":"parallel programming","slug":"parallel-programming","permalink":"https://ben-xj.github.io/tags/parallel-programming/"},{"name":"joblib","slug":"joblib","permalink":"https://ben-xj.github.io/tags/joblib/"},{"name":"ray","slug":"ray","permalink":"https://ben-xj.github.io/tags/ray/"},{"name":"multiprocessing","slug":"multiprocessing","permalink":"https://ben-xj.github.io/tags/multiprocessing/"},{"name":"java","slug":"java","permalink":"https://ben-xj.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"https://ben-xj.github.io/tags/lombok/"},{"name":"mapstruct","slug":"mapstruct","permalink":"https://ben-xj.github.io/tags/mapstruct/"},{"name":"maven","slug":"maven","permalink":"https://ben-xj.github.io/tags/maven/"},{"name":"pip","slug":"pip","permalink":"https://ben-xj.github.io/tags/pip/"},{"name":"cpp","slug":"cpp","permalink":"https://ben-xj.github.io/tags/cpp/"},{"name":"pybind11","slug":"pybind11","permalink":"https://ben-xj.github.io/tags/pybind11/"},{"name":"pulp","slug":"pulp","permalink":"https://ben-xj.github.io/tags/pulp/"},{"name":"solver","slug":"solver","permalink":"https://ben-xj.github.io/tags/solver/"},{"name":"mip","slug":"mip","permalink":"https://ben-xj.github.io/tags/mip/"},{"name":"cython","slug":"cython","permalink":"https://ben-xj.github.io/tags/cython/"},{"name":"django","slug":"django","permalink":"https://ben-xj.github.io/tags/django/"},{"name":"后端框架","slug":"后端框架","permalink":"https://ben-xj.github.io/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"api","slug":"api","permalink":"https://ben-xj.github.io/tags/api/"},{"name":"shell","slug":"shell","permalink":"https://ben-xj.github.io/tags/shell/"},{"name":"tmux","slug":"tmux","permalink":"https://ben-xj.github.io/tags/tmux/"},{"name":"凸优化","slug":"凸优化","permalink":"https://ben-xj.github.io/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","permalink":"https://ben-xj.github.io/tags/%E7%88%AC%E8%99%AB/"}]}